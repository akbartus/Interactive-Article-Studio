<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Article Studio</title>
     <link rel="icon" href="icon.ico" type="image/x-icon">
    <script src="aframe.min.js"></script>
    <script src="post-processing.js"></script>
    <script src="transform-controls-multi.js"></script>
    <script src="gaussian-splat-viewer.js"></script>
    <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>
    <script src="scene-manager.js"></script>

    <!-- Add Quill Rich Text Editor -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <style>

    #logo {
    height: 40px;
    max-width: 200px;
    object-fit: contain;
    margin-right: 16px;
    cursor: pointer;
}

#logo:hover {
    opacity: 0.8;
}    
        /* ═══════════════════════════════════════════════════════════════
   CENTERED NOTIFICATIONS
   ═══════════════════════════════════════════════════════════════ */
        .notification-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10001;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(2px);
        }

        .notification-overlay.active {
            display: flex;
        }

        .notification-box {
            background: white;
            padding: 24px 32px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            min-width: 300px;
            text-align: center;
            animation: notificationSlideIn 0.3s ease-out;
        }

        @keyframes notificationSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .notification-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .notification-message {
            font-size: 16px;
            color: #2d3748;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .notification-box.success .notification-icon {
            color: #48bb78;
        }

        .notification-box.error .notification-icon {
            color: #f56565;
        }

        .notification-box.warning .notification-icon {
            color: #ed8936;
        }

        .notification-box.info .notification-icon {
            color: #4299e1;
        }


        /* ═══════════════════════════════════════════════════════════════
           HOTSPOT STYLES
           ═══════════════════════════════════════════════════════════════ */
        .hotspot-marker {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            z-index: 10;
        }

        .hotspot-marker.info {
            background: rgba(66, 153, 225, 0.9);
            border: 3px solid #2c5282;
            color: white;
        }

        .hotspot-marker.eye {
            background: rgba(72, 187, 120, 0.9);
            border: 3px solid #22543d;
            color: white;
        }

        .hotspot-marker:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .hotspot-tooltip {
            position: absolute;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-width: 300px;
            display: none;
            pointer-events: none;
        }

        .hotspot-tooltip.active {
            display: block;
        }

        .hotspot-tooltip img {
            max-width: 100%;
            border-radius: 4px;
            margin-top: 8px;
        }

        /* ═══════════════════════════════════════════════════════════════
        RICH TEXT EDITOR
        ═══════════════════════════════════════════════════════════════ */
        .quill-editor-container {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .ql-container {
            min-height: 80px;
            font-size: 14px;
        }

        .ql-editor {
            min-height: 80px;
        }

        .text-input-row .ql-toolbar {
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            background: #f7fafc;
        }

        .text-input-row .ql-container {
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
        }

        /* ═══════════════════════════════════════════════════════════════
           RESET & BASE STYLES
           ═══════════════════════════════════════════════════════════════ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f7fa;
            color: #2d3748;
            overflow: hidden;
        }

        /* ═══════════════════════════════════════════════════════════════
           CUSTOM SCROLLBAR
           ═══════════════════════════════════════════════════════════════ */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }

        /* ═══════════════════════════════════════════════════════════════
           TOP NAVIGATION BAR
           ═══════════════════════════════════════════════════════════════ */
        #buttons-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            background: #ffffff;
            height: 60px;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border-bottom: 1px solid #e2e8f0;
        }

        #buttons-container button {
            height: 38px;
            padding: 0 20px;
            background: #ffffff;
            color: #4a5568;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        #buttons-container button:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
            color: #2d3748;
            transform: translateY(-1px);
        }

        #buttons-container button:active {
            transform: translateY(0);
        }

        /* ═══════════════════════════════════════════════════════════════
           CONTROLS TOOLBAR (Right Side)
           ═══════════════════════════════════════════════════════════════ */
        .controls-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            background: #ffffff;
            padding: 12px 16px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .transform-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .controls-separator {
            width: 1px;
            height: 30px;
            background: #e2e8f0;
            margin: 0 4px;
        }

        .transform-icon {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
            position: relative;
        }

        .transform-icon:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .transform-icon:active {
            transform: translateY(0);
        }

        .transform-icon.active {
            background: #4299e1;
            border-color: #3182ce;
        }

        .transform-icon.active img {
            filter: brightness(0) invert(1);
            opacity: 1;
        }

        .transform-icon img {
            width: 24px;
            height: 24px;
            opacity: 0.7;
        }

        .transform-icon:hover img {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════
           SIDE PANELS
           ═══════════════════════════════════════════════════════════════ */
        .panel {
            position: fixed;
            top: 60px;
            left: 0;
            width: 340px;
            height: calc(100vh - 60px);
            background: #ffffff;
            box-shadow: 2px 0 16px rgba(0, 0, 0, 0.08);
            padding: 24px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            border-right: 1px solid #e2e8f0;
        }

        .panel h3 {
            font-size: 20px;
            font-weight: 600;
            color: #1a202c;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .panel h4 {
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
            margin: 20px 0 12px 0;
        }

        .panel label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .panel p {
            font-size: 14px;
            color: #718096;
            margin: 8px 0;
        }

        /* ═══════════════════════════════════════════════════════════════
           INPUT FIELDS
           ═══════════════════════════════════════════════════════════════ */
        .panel input[type="text"],
        .panel input[type="number"],
        .panel input[type="file"],
        .panel textarea,
        .panel select {
            width: 100%;
            padding: 10px 12px;
            font-size: 14px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            color: #2d3748;
            margin-bottom: 16px;
            transition: all 0.2s ease;
        }

        .panel input[type="text"]:focus,
        .panel input[type="number"]:focus,
        .panel textarea:focus,
        .panel select:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .panel textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        /* ═══════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════ */
        .slider-container {
            margin-bottom: 20px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-header label {
            margin-bottom: 0;
        }

        .slider-value {
            font-size: 14px;
            font-weight: 600;
            color: #4299e1;
            background: #ebf8ff;
            padding: 4px 10px;
            border-radius: 4px;
            min-width: 50px;
            text-align: center;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #3182ce;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #3182ce;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* ═══════════════════════════════════════════════════════════════
           BUTTONS - GOOGLE MATERIAL DESIGN STYLE (2 COLORS)
           ═══════════════════════════════════════════════════════════════ */
        #add-article-section-btn,
        #add-3d-section-btn,
        #add-hotspot-section-btn,
        #add-video-section-btn {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #add-article-section-btn svg,
        #add-3d-section-btn svg,
        #add-hotspot-section-btn svg,
        #add-video-section-btn svg {
            flex-shrink: 0;
            margin-right: 2px;
        }

        #add-article-section-btn span,
        #add-3d-section-btn span,
        #add-hotspot-section-btn span,
        #add-video-section-btn span {
            text-align: left;
            line-height: 1.3;
        }



        .panel button {
            width: 100%;
            padding: 10px 16px;
            background: #4299e1;
            /* Blue - Primary */
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 8px;
            letter-spacing: 0.25px;
        }

        .panel button:hover {
            background: #3182ce;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(66, 153, 225, 0.3);
        }

        .panel button:active {
            transform: translateY(0);
        }

        .button-container {
            display: flex;
            gap: 8px;
            margin: 12px 0;
        }

        .button-container button {
            flex: 1;
            margin: 0;
            padding: 9px 14px;
        }

        /* Button Variants - Destructive/Cancel (Gray) */
        #deleteButton,
        .delete-slide-button,
        #delete-annotation-btn,
        #delete-hotspot-btn,
        #delete-video-btn,
        #delete-project-btn,
        #clear-keyframes-btn,
        #endButton {
            background: #e2e8f0 !important;
            /* Light Gray */
            color: #4a5568 !important;
        }

        #deleteButton:hover,
        .delete-slide-button:hover,
        #delete-annotation-btn:hover,
        #delete-hotspot-btn:hover,
        #delete-video-btn:hover,
        #delete-project-btn:hover,
        #clear-keyframes-btn:hover,
        #endButton:hover {
            background: #cbd5e0 !important;
        }

        /* Button Variants - Success/Confirm (Blue) */
        #startButton,
        #add-keyframe-btn,
        #create-annotation-btn,
        #add-hotspot-btn,
        #add-video-btn,
        #add-article-section-btn {
            background: #4299e1 !important;
            /* Blue */
        }

        #startButton:hover,
        #add-keyframe-btn:hover,
        #create-annotation-btn:hover,
        #add-hotspot-btn:hover,
        #add-video-btn:hover,
        #add-article-section-btn:hover {
            background: #3182ce !important;
        }

        /* Remove inline style overrides */
        button[style*="background: #6f42c1"],
        button[style*="background: #17a2b8"],
        button[style*="background: #28a745"] {
            margin: 0 !important;
        }

        /* ═══════════════════════════════════════════════════════════════
           CONTENT BLOCKS
           ═══════════════════════════════════════════════════════════════ */
        .content-block {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .content-block h4 {
            margin: 0 0 12px 0;
            font-size: 15px;
            color: #2d3748;
        }

        .content-block p {
            font-size: 13px;
            color: #718096;
            margin: 0 0 12px 0;
            line-height: 1.5;
        }

        /* ═══════════════════════════════════════════════════════════════
           INPUT GROUPS
           ═══════════════════════════════════════════════════════════════ */
        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }

        .input-row input {
            flex: 1;
            width: auto !important;
            margin-bottom: 0;
        }

        .input-group {
            flex: 1;
        }

        .input-group label {
            font-size: 12px;
            margin-bottom: 6px;
        }

        .input-group input {
            width: 100%;
            margin-bottom: 0;
        }

        #font-other,
        #font-other2 {
            display: flex;
            gap: 10px;
            margin: 16px 0;
        }

        /* ═══════════════════════════════════════════════════════════════
           ALIGNMENT ICONS
           ═══════════════════════════════════════════════════════════════ */
        .align-icons {
            display: flex;
            gap: 8px;
            margin: 16px 0;
        }

        .align-icon {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            transition: all 0.2s ease;
        }

        .align-icon:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
            transform: translateY(-2px);
        }

        .align-icon img {
            width: 22px;
            height: 22px;
            opacity: 0.7;
        }

        .align-icon:hover img {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════
           FILE INPUT CUSTOM STYLING
           ═══════════════════════════════════════════════════════════════ */
        input[type="file"] {
            position: relative;
            cursor: pointer;
            padding: 12px;
            border: 2px dashed #cbd5e0 !important;
            background: #f7fafc !important;
        }

        input[type="file"]:hover {
            border-color: #4299e1 !important;
            background: #ebf8ff !important;
        }

        input[type="file"]::file-selector-button {
            padding: 8px 16px;
            margin-right: 12px;
            background: #4299e1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        input[type="file"]::file-selector-button:hover {
            background: #3182ce;
        }

        /* ═══════════════════════════════════════════════════════════════
           PROJECT LIST
           ═══════════════════════════════════════════════════════════════ */
        .project-list-item {
            padding: 14px;
            margin: 8px 0;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .project-list-item:hover {
            background: #f7fafc;
            border-color: #4299e1;
            transform: translateX(4px);
        }

        .project-list-item.selected {
            background: #ebf8ff;
            border-color: #4299e1;
            box-shadow: 0 2px 8px rgba(66, 153, 225, 0.2);
        }

        .project-name {
            font-weight: 600;
            font-size: 14px;
            color: #2d3748;
            margin-bottom: 4px;
        }

        .project-date {
            font-size: 12px;
            color: #a0aec0;
        }

        /* ═══════════════════════════════════════════════════════════════
           STATUS MESSAGES
           ═══════════════════════════════════════════════════════════════ */
        .status-message {
            padding: 12px 16px;
            margin: 16px 0;
            border-radius: 6px;
            display: none;
            font-size: 14px;
            font-weight: 500;
        }

        .status-message.success {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .status-message.error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #fc8181;
        }

        /* ═══════════════════════════════════════════════════════════════
           TEXT OVERLAY
           ═══════════════════════════════════════════════════════════════ */
        .text-overlay {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            /* Changed to white/light */
            color: #2d3748;
            /* Changed text to dark */
            padding: 16px 32px;
            border-radius: 8px;
            transition: bottom 0.5s ease, opacity 0.5s ease;
            opacity: 0;
            z-index: 10000;
            font-size: 18px;
            font-weight: 500;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .text-overlay.visible {
            bottom: 50%;
            opacity: 1;
        }

        .text-overlay.hidden {
            bottom: -100px;
            opacity: 0;
        }

        /* ═══════════════════════════════════════════════════════════════
           TEXT INPUTS CONTAINER (Scrollytelling)
           ═══════════════════════════════════════════════════════════════ */
        .text-inputs-container {
            max-height: 400px;
            overflow-y: auto;
            padding: 4px;
        }

        .text-input-row {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 14px;
            margin-bottom: 12px;
        }

        .text-input-row .slideTitle {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 10px;
            text-transform: none;
            letter-spacing: normal;
        }

        .text-input-row input {
            margin-bottom: 8px;
        }

        .text-input-row .frameNumber,
        .text-input-row .durationFrames {
            width: calc(50% - 5px) !important;
            display: inline-block !important;
        }

        .text-input-row .frameNumber {
            margin-right: 10px;
        }

        .delete-slide-button {
            width: 100% !important;
            padding: 8px !important;
            margin-top: 8px;
            margin-bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════
           MODAL DIALOG
           ═══════════════════════════════════════════════════════════════ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-dialog {
            background: white;
            padding: 32px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 420px;
            width: 90%;
        }

        .modal-dialog h3 {
            margin: 0 0 20px 0;
            color: #1a202c;
            font-size: 22px;
            font-weight: 600;
        }

        .modal-dialog label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 8px;
        }

        .modal-dialog input {
            width: 100%;
            padding: 12px;
            margin-bottom: 24px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .modal-dialog input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 10px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-buttons .btn-cancel {
            background: #e2e8f0;
            color: #4a5568;
        }

        .modal-buttons .btn-cancel:hover {
            background: #cbd5e0;
        }

        .modal-buttons .btn-save {
            background: #4299e1;
            color: white;
        }

        .modal-buttons .btn-save:hover {
            background: #3182ce;
        }

        /* ═══════════════════════════════════════════════════════════════
           KEYFRAMES LIST
           ═══════════════════════════════════════════════════════════════ */
        #keyframes-list {
            max-height: 240px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            background: #ffffff;
            margin-bottom: 16px;
        }

        #keyframes-list>div {
            padding: 12px;
            margin: 8px 0;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.6;
        }

        #keyframes-list strong {
            color: #2d3748;
            font-size: 14px;
        }

        #keyframes-list small {
            color: #718096;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* ═══════════════════════════════════════════════════════════════
           A-FRAME SCENE
           ═══════════════════════════════════════════════════════════════ */
        a-scene {
            position: fixed;
            top: 60px;
            left: 0;
            width: 100%;
            height: calc(100vh - 60px);
        }

        /* ═══════════════════════════════════════════════════════════════
           SEPARATOR LINES
           ═══════════════════════════════════════════════════════════════ */
        hr {
            border: none;
            border-top: 1px solid #e2e8f0;
            margin: 24px 0;
        }

        /* ═══════════════════════════════════════════════════════════════
           HIDDEN ELEMENTS
           ═══════════════════════════════════════════════════════════════ */
        #fly,
        #wasd,
        #downloadButton,
        #testAnimation {
            display: none;
        }

        #gltf-loader {
            z-index: 9999;
        }

        /* ═══════════════════════════════════════════════════════════════
           SPECIFIC ADJUSTMENTS
           ═══════════════════════════════════════════════════════════════ */
        #preloadGS,
        #preloadGLTF {
            margin-top: 0;
        }

        .save-load-buttons {
            display: grid;
            gap: 10px;
            margin: 16px 0;
        }

        .save-load-buttons button {
            flex: 1;
            margin: 0;
        }

        #project-list {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 12px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .panel {
                width: 100%;
            }

            #buttons-container {
                flex-wrap: wrap;
                height: auto;
                padding: 10px;
            }

            .controls-container {
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                flex-wrap: wrap;
                justify-content: center;
                max-width: 90%;
            }
        }
    </style>

    <script>
        let controlPanel;
        let blinkInterval;
        let tooltipCount = 0;
        let tooltips = [];

        // ────────────────────────────────────────────────
        //   CAMERA WAYPOINTS (manually added positions)
        // ────────────────────────────────────────────────
        let cameraWaypoints = [];
        let waypointCounter = 0;


        // Annotation management
        let annotationsList = [];
        let selectedAnnotationId = null;
        let annotationQuill = null;

        AFRAME.registerComponent("tooltip-component", {
            init: function () {
                // Initialize on DOMContentLoaded instead
            }
        });

        // NEW CODE
        function initializeAnnotations() {
            // Initialize Quill editor for annotations
            annotationQuill = new Quill('#annotation-editor', {
                theme: 'snow',
                placeholder: 'Enter annotation text...',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline'],
                        [{ 'color': [] }, { 'background': [] }],
                        [{ 'align': [] }],
                        ['clean']
                    ]
                }
            });

            // Create annotation button
            document.getElementById('create-annotation-btn')?.addEventListener('click', () => {
                openAnnotationModal();
            });

            // Edit annotation button
            document.getElementById('edit-annotation-btn')?.addEventListener('click', () => {
                editSelectedAnnotation();
            });

            // Delete annotation button
            document.getElementById('delete-annotation-btn')?.addEventListener('click', () => {
                deleteSelectedAnnotation();
            });
        }

        function openAnnotationModal(editMode = false) {
            const modal = document.getElementById('annotation-modal');
            const modalTitle = document.getElementById('annotation-modal-title');
            const saveBtn = document.getElementById('annotation-save-btn');

            if (editMode && selectedAnnotationId) {
                // Edit mode - populate with existing annotation
                const annotation = annotationsList.find(a => a.id === selectedAnnotationId);
                if (!annotation) return;

                modalTitle.textContent = 'Edit Annotation';
                saveBtn.textContent = 'Update';
                saveBtn.onclick = updateAnnotation;

                document.getElementById('annotation-name-input').value = annotation.name;
                document.getElementById('annotation-bg-color').value = annotation.bgColor;
                document.getElementById('annotation-font-size').value = annotation.fontSize;
                document.getElementById('annotation-font-size-value').textContent = annotation.fontSize;
                document.getElementById('annotation-max-width').value = annotation.maxWidth;
                document.getElementById('annotation-max-width-value').textContent = annotation.maxWidth;
                annotationQuill.root.innerHTML = annotation.htmlContent;
            } else {
                // Create mode - reset form
                modalTitle.textContent = 'Create Annotation';
                saveBtn.textContent = 'Create';
                saveBtn.onclick = createAnnotation;

                document.getElementById('annotation-name-input').value = '';
                document.getElementById('annotation-bg-color').value = '#ffffff';
                document.getElementById('annotation-font-size').value = '0.5';
                document.getElementById('annotation-font-size-value').textContent = '0.5';
                document.getElementById('annotation-max-width').value = '2';
                document.getElementById('annotation-max-width-value').textContent = '2';
                annotationQuill.setText('');
            }

            modal.classList.add('active');
        }

        function closeAnnotationModal() {
            document.getElementById('annotation-modal').classList.remove('active');
        }

        // CORRECTED createAnnotation function
        function createAnnotation() {
            const name = document.getElementById('annotation-name-input').value.trim();
            const bgColor = document.getElementById('annotation-bg-color').value;
            const fontSize = parseFloat(document.getElementById('annotation-font-size').value);
            const maxWidth = parseFloat(document.getElementById('annotation-max-width').value);
            const textContent = annotationQuill.getText().trim();

            if (!name) {
                showNotification('Please enter an annotation name', 'warning');
                return;
            }

            if (!textContent) {
                showNotification('Please enter annotation text', 'warning');
                return;
            }

            tooltipCount++;
            const annotationId = `annotation-${tooltipCount}`;

            // Create container entity for text + background
            const scene = document.querySelector("a-scene");
            const container = document.createElement("a-entity");
            container.setAttribute("id", annotationId);
            container.setAttribute("position", "0 1.6 -2");
            container.setAttribute("rotation", "0 0 0");

            // Get HTML content with formatting
            const htmlContent = annotationQuill.root.innerHTML;

            // Create the text FIRST
            const newText = document.createElement("a-troika-text");
            newText.setAttribute("color", "#2d3748");
            newText.setAttribute("value", textContent);
            newText.setAttribute("align", "center");
            newText.setAttribute("fill-opacity", "1");
            newText.setAttribute("font-size", fontSize);
            newText.setAttribute("line-height", "1.2");
            newText.setAttribute("max-width", maxWidth);
            newText.setAttribute("position", "0 0 0");
            newText.setAttribute("anchor", "center");
            newText.setAttribute("baseline", "center");
            newText.setAttribute("white-space", "normal");
            container.appendChild(newText);

            // Create background plane with INITIAL valid dimensions
            const background = document.createElement("a-plane");
            background.setAttribute("class", "annotation-background");
            background.setAttribute("color", bgColor);
            background.setAttribute("opacity", "0.9");
            background.setAttribute("position", "0 0 -0.01");
            // Set initial valid dimensions to prevent NaN error
            background.setAttribute("width", maxWidth + 0.2);
            background.setAttribute("height", fontSize * 2);
            container.appendChild(background);

            scene.appendChild(container);

            // Wait for text to sync, then calculate proper background size
            setTimeout(() => {
                try {
                    const textObj = newText.object3D.children.find(child => child.geometry);
                    if (textObj && textObj.geometry) {
                        textObj.geometry.computeBoundingBox();
                        const bbox = textObj.geometry.boundingBox;

                        if (bbox && isFinite(bbox.max.x) && isFinite(bbox.min.x)) {
                            const textWidth = bbox.max.x - bbox.min.x;
                            const textHeight = bbox.max.y - bbox.min.y;

                            // Add padding and ensure valid values
                            const padding = 0.15;
                            const finalWidth = Math.max(textWidth + padding, 0.5);
                            const finalHeight = Math.max(textHeight + padding, 0.3);

                            background.setAttribute("width", finalWidth);
                            background.setAttribute("height", finalHeight);
                        } else {
                            // Fallback calculation
                            const lines = textContent.split('\n').length;
                            const estimatedHeight = Math.max(lines * fontSize * 1.2 + 0.2, 0.3);
                            background.setAttribute("width", maxWidth + 0.2);
                            background.setAttribute("height", estimatedHeight);
                        }
                    }
                } catch (error) {
                    console.warn('Could not calculate text bounds, using fallback dimensions:', error);
                    // Keep initial dimensions as fallback
                }
            }, 150);

            // Add to annotations list
            annotationsList.push({
                id: annotationId,
                name: name,
                text: textContent,
                htmlContent: htmlContent,
                fontSize: fontSize,
                maxWidth: maxWidth,
                bgColor: bgColor
            });

            // Update UI
            updateAnnotationsList();

            // Initialize editor for the new annotation
            window.setTimeout(() => {
                new Editor();
            }, 100);

            closeAnnotationModal();
            showNotification(`Annotation "${name}" created successfully`, 'success');
        }

        // CORRECTED updateAnnotation function
        function updateAnnotation() {
            if (!selectedAnnotationId) return;

            const name = document.getElementById('annotation-name-input').value.trim();
            const bgColor = document.getElementById('annotation-bg-color').value;
            const fontSize = parseFloat(document.getElementById('annotation-font-size').value);
            const maxWidth = parseFloat(document.getElementById('annotation-max-width').value);
            const textContent = annotationQuill.getText().trim();

            if (!name) {
                showNotification('Please enter an annotation name', 'warning');
                return;
            }

            if (!textContent) {
                showNotification('Please enter annotation text', 'warning');
                return;
            }

            // Find the annotation in the list
            const annotation = annotationsList.find(a => a.id === selectedAnnotationId);
            if (!annotation) return;

            // Update annotation data
            annotation.name = name;
            annotation.text = textContent;
            annotation.htmlContent = annotationQuill.root.innerHTML;
            annotation.fontSize = fontSize;
            annotation.maxWidth = maxWidth;
            annotation.bgColor = bgColor;

            // Update the 3D entity
            const container = document.getElementById(selectedAnnotationId);
            if (container) {
                // Update text first
                const textEntity = container.querySelector('a-troika-text');
                if (textEntity) {
                    textEntity.setAttribute("value", textContent);
                    textEntity.setAttribute("font-size", fontSize);
                    textEntity.setAttribute("max-width", maxWidth);
                    textEntity.setAttribute("anchor", "center");
                    textEntity.setAttribute("baseline", "center");
                    textEntity.setAttribute("white-space", "normal");
                }

                // Update background
                const background = container.querySelector('a-plane');
                if (background) {
                    background.setAttribute("color", bgColor);

                    // Set initial valid dimensions first
                    background.setAttribute("width", maxWidth + 0.2);
                    background.setAttribute("height", fontSize * 2);

                    // Recalculate background size based on text
                    setTimeout(() => {
                        try {
                            const textObj = textEntity.object3D.children.find(child => child.geometry);
                            if (textObj && textObj.geometry) {
                                textObj.geometry.computeBoundingBox();
                                const bbox = textObj.geometry.boundingBox;

                                if (bbox && isFinite(bbox.max.x) && isFinite(bbox.min.x)) {
                                    const textWidth = bbox.max.x - bbox.min.x;
                                    const textHeight = bbox.max.y - bbox.min.y;

                                    // Add padding and ensure valid values
                                    const padding = 0.15;
                                    const finalWidth = Math.max(textWidth + padding, 0.5);
                                    const finalHeight = Math.max(textHeight + padding, 0.3);

                                    background.setAttribute("width", finalWidth);
                                    background.setAttribute("height", finalHeight);
                                } else {
                                    // Fallback
                                    const lines = textContent.split('\n').length;
                                    const estimatedHeight = Math.max(lines * fontSize * 1.2 + 0.2, 0.3);
                                    background.setAttribute("width", maxWidth + 0.2);
                                    background.setAttribute("height", estimatedHeight);
                                }
                            }
                        } catch (error) {
                            console.warn('Could not calculate text bounds, using fallback dimensions:', error);
                            // Keep initial dimensions as fallback
                        }
                    }, 150);
                }
            }

            // Update UI
            updateAnnotationsList();

            closeAnnotationModal();
            showNotification(`Annotation "${name}" updated successfully`, 'success');
        }


        function updateAnnotationsList() {
            const container = document.getElementById('annotations-list');

            if (annotationsList.length === 0) {
                container.innerHTML = '<p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">No annotations yet. Click "Create Annotation" to add one.</p>';
                return;
            }

            let html = '';
            annotationsList.forEach((annotation) => {
                const isSelected = selectedAnnotationId === annotation.id;
                html += `
                <div class="project-list-item ${isSelected ? 'selected' : ''}" 
                    onclick="selectAnnotation('${annotation.id}')"
                    style="cursor: pointer;">
                    <div class="project-name">${annotation.name}</div>
                    <div class="project-date">Font size: ${annotation.fontSize}, Max width: ${annotation.maxWidth}</div>
                </div>
            `;
            });

            container.innerHTML = html;
        }

        function selectAnnotation(annotationId) {
            selectedAnnotationId = annotationId;
            updateAnnotationsList();
        }

        function deleteSelectedAnnotation() {
            if (!selectedAnnotationId) {
                showNotification('Please select an annotation to delete', 'warning');
                return;
            }

            // Find the annotation
            const annotation = annotationsList.find(a => a.id === selectedAnnotationId);
            if (!annotation) return;

            if (!confirm(`Delete annotation "${annotation.name}"?`)) {
                return;
            }

            // Remove from scene
            const element = document.getElementById(selectedAnnotationId);
            if (element) {
                element.parentNode.removeChild(element);
            }

            // Remove from list
            annotationsList = annotationsList.filter(a => a.id !== selectedAnnotationId);
            selectedAnnotationId = null;

            // Update UI
            updateAnnotationsList();
            showNotification('Annotation deleted', 'success');
        }

        // ═══════════════════════════════════════════════════════════════
        // HOTSPOT MANAGEMENT
        // ═══════════════════════════════════════════════════════════════

        let hotspotsList = [];
        let selectedHotspotId = null;
        let currentHotspotImage = null;
        let hotspotMarkers = [];
        let currentEditingMarker = null;
        // Video management
        let videosList = [];
        let selectedVideoId = null;
        // Audio management
        let audiosList = [];
        let selectedAudioId = null;
        let currentGeneratedAudio = null;

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('add-hotspot-btn')?.addEventListener('click', openHotspotModal);
            document.getElementById('edit-hotspot-btn')?.addEventListener('click', editSelectedHotspot);
            document.getElementById('delete-hotspot-btn')?.addEventListener('click', deleteSelectedHotspot);

            // Image upload handler
            document.getElementById('hotspot-image-upload')?.addEventListener('change', handleHotspotImageUpload);
            // Drag and drop handlers
            const draggables = document.querySelectorAll('.hotspot-type-draggable');
            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', handleDragStart);
            });

            // VIDEO EVENT LISTENERS - ADD THESE
            document.getElementById('add-video-btn')?.addEventListener('click', openAddVideoModal);
            document.getElementById('delete-video-btn')?.addEventListener('click', deleteSelectedVideo);
            document.getElementById('add-video-section-btn')?.addEventListener('click', () => {
                openVideoSectionModal();
            });
            document.getElementById('add-audio-section-btn')?.addEventListener('click', () => {
                openAudioSectionModal();
            });

            // Audio panel buttons
            document.getElementById('save-audio-btn')?.addEventListener('click', saveGeneratedAudio);
            document.getElementById('delete-audio-btn')?.addEventListener('click', deleteSelectedAudio);

            // Generate Audio button listener - moved to panel
            document.getElementById('generate-audio-btn')?.addEventListener('click', async () => {
                const text = document.getElementById('audio-text-input').value.trim();
                const voice = document.getElementById('audio-voice-select').value;
                const dtype = document.getElementById('audio-dtype-select').value;

                if (!text) {
                    showNotification('Please enter text to convert to speech', 'warning');
                    return;
                }

                const button = document.getElementById('generate-audio-btn');
                button.disabled = true;
                button.textContent = 'Generating...';

                try {
                    const response = await fetch('/api/generate-audio', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text, voice, dtype, device: 'cpu' })
                    });

                    const result = await response.json();

                    if (result.success) {
                        currentGeneratedAudio = {  // ✅ CORRECT VARIABLE
                            text: text,
                            audioUrl: result.audioUrl,
                            voice: voice,
                            dtype: dtype
                        };
                        showAudioPreview(result.audioUrl, text);
                        showNotification('Audio generated successfully!', 'success');
                    } else {
                        throw new Error(result.error || 'Unknown error');
                    }
                } catch (err) {
                    console.error('Audio generation error:', err);
                    showNotification(`Failed to generate audio: ${err.message}`, 'error');
                } finally {
                    button.disabled = false;
                    button.textContent = 'Generate Audio';
                }
            });
            // Video upload preview handler
            document.getElementById('video-upload-input')?.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const preview = document.getElementById('video-preview');
                        const container = document.getElementById('video-preview-container');
                        preview.src = event.target.result;
                        container.style.display = 'block';
                    };
                    reader.readAsDataURL(file);
                }
            });
        });

        function openHotspotModal() {
            const modal = document.getElementById('hotspot-modal');

            // Reset
            document.getElementById('hotspot-name-input').value = '';
            document.getElementById('hotspot-image-upload').value = '';
            document.getElementById('hotspot-canvas-container').style.display = 'none';
            document.getElementById('hotspot-types').style.display = 'none';

            // Clear any existing markers from the container
            const container = document.getElementById('hotspot-canvas-container');
            container.querySelectorAll('.hotspot-marker').forEach(m => m.remove());

            hotspotMarkers = [];
            currentHotspotImage = null;

            // Make sure the button says "Create"
            const createBtn = modal.querySelector('.btn-save');
            createBtn.textContent = 'Create';
            createBtn.onclick = createHotspotEntity;

            modal.classList.add('active');
        }

        function closeHotspotModal() {
            const modal = document.getElementById('hotspot-modal');
            modal.classList.remove('active');

            // Clean up markers from container
            const container = document.getElementById('hotspot-canvas-container');
            container.querySelectorAll('.hotspot-marker').forEach(m => m.remove());

            // Reset button
            const createBtn = modal.querySelector('.btn-save');
            createBtn.textContent = 'Create';
            createBtn.onclick = createHotspotEntity;
        }

        function handleHotspotImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const img = document.getElementById('hotspot-preview-image');
                const canvas = document.getElementById('hotspot-canvas');
                const container = document.getElementById('hotspot-canvas-container');

                img.src = event.target.result;
                currentHotspotImage = event.target.result;

                img.onload = function () {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    container.style.display = 'block';
                    document.getElementById('hotspot-types').style.display = 'block';

                    // Setup canvas for hotspot placement
                    setupHotspotCanvas();
                };
            };
            reader.readAsDataURL(file);
        }

        function setupHotspotCanvas() {
            const canvas = document.getElementById('hotspot-canvas');
            const container = document.getElementById('hotspot-canvas-container');

            // Handle drop on canvas
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                const hotspotType = e.dataTransfer.getData('hotspotType');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                addHotspotMarker(x, y, hotspotType);
            });
        }

        function handleDragStart(e) {
            e.dataTransfer.setData('hotspotType', e.target.dataset.type);
        }

        function addHotspotMarker(x, y, type) {
            const container = document.getElementById('hotspot-canvas-container');
            const marker = document.createElement('div');
            marker.className = `hotspot-marker ${type}`;
            marker.style.left = x + 'px';
            marker.style.top = y + 'px';
            marker.innerHTML = type === 'info' ? 'ℹ️' : '👁️';

            const markerId = 'marker-' + Date.now() + '-' + Math.random();
            marker.dataset.markerId = markerId;
            marker.dataset.type = type;

            // Make marker clickable to edit
            marker.addEventListener('click', (e) => {
                e.stopPropagation();
                openHotspotInfoModal(markerId, type);
            });

            // Add right-click to delete marker
            marker.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (confirm('Delete this hotspot marker?')) {
                    marker.remove();
                    hotspotMarkers = hotspotMarkers.filter(m => m.id !== markerId);
                }
            });

            container.appendChild(marker);

            hotspotMarkers.push({
                id: markerId,
                x: x,
                y: y,
                type: type,
                text: '',
                image: null
            });
        }

        function openHotspotInfoModal(markerId, type) {
            currentEditingMarker = hotspotMarkers.find(m => m.id === markerId);

            const modal = document.getElementById('hotspot-info-modal');
            const title = document.getElementById('hotspot-info-title');
            const imageSection = document.getElementById('hotspot-image-section');
            const textInput = document.getElementById('hotspot-text-input');
            const preview = document.getElementById('hotspot-image-preview');

            title.textContent = type === 'info' ? 'Edit Info Hotspot' : 'Edit Eye Hotspot';
            imageSection.style.display = type === 'eye' ? 'block' : 'none';

            if (currentEditingMarker) {
                textInput.value = currentEditingMarker.text || '';

                // Show existing image if present
                if (type === 'eye' && currentEditingMarker.image) {
                    preview.innerHTML = `<img src="${currentEditingMarker.image}" style="max-width: 200px; border-radius: 4px;">`;
                } else {
                    preview.innerHTML = '';
                }
            }

            modal.classList.add('active');
        }

        function closeHotspotInfoModal() {
            document.getElementById('hotspot-info-modal').classList.remove('active');
            currentEditingMarker = null;
        }

        function saveHotspotInfo() {
            if (!currentEditingMarker) return;

            const text = document.getElementById('hotspot-text-input').value;
            currentEditingMarker.text = text;

            // Handle image for eye type
            if (currentEditingMarker.type === 'eye') {
                const imageFile = document.getElementById('hotspot-detail-image').files[0];
                if (imageFile) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        currentEditingMarker.image = e.target.result;
                        // Update preview
                        const preview = document.getElementById('hotspot-image-preview');
                        preview.innerHTML = `<img src="${e.target.result}" style="max-width: 200px; border-radius: 4px;">`;
                        closeHotspotInfoModal();
                    };
                    reader.readAsDataURL(imageFile);
                } else {
                    closeHotspotInfoModal();
                }
            } else {
                closeHotspotInfoModal();
            }
        }

        function createHotspotEntity() {
            if (!currentHotspotImage || hotspotMarkers.length === 0) {
                showNotification('Please upload an image and add at least one hotspot', 'warning');
                return;
            }

            const hotspotId = 'hotspot-' + Date.now();
            const hotspotName = document.getElementById('hotspot-name-input')?.value?.trim() || `Hotspot ${hotspotsList.length + 1}`;

            // Get image dimensions from the preview
            const previewImg = document.getElementById('hotspot-preview-image');
            const imgWidth = previewImg.naturalWidth;
            const imgHeight = previewImg.naturalHeight;

            // Store hotspot data (NOT creating 3D entity)
            hotspotsList.push({
                id: hotspotId,
                name: hotspotName,
                image: currentHotspotImage,
                imageWidth: imgWidth,
                imageHeight: imgHeight,
                markers: JSON.parse(JSON.stringify(hotspotMarkers))
            });

            updateHotspotsList();
            closeHotspotModal();
            showNotification(`Hotspot "${hotspotName}" created successfully`, 'success');
        }

        function editSelectedHotspot() {
            if (!selectedHotspotId) {
                showNotification('Please select a hotspot to edit', 'warning');
                return;
            }

            const hotspot = hotspotsList.find(h => h.id === selectedHotspotId);
            if (!hotspot) return;

            // Open modal in edit mode
            openHotspotModalForEdit(hotspot);
        }

        function openHotspotModalForEdit(hotspot) {
            const modal = document.getElementById('hotspot-modal');

            // Set the name
            document.getElementById('hotspot-name-input').value = hotspot.name;

            // Load the image
            const img = document.getElementById('hotspot-preview-image');
            const canvas = document.getElementById('hotspot-canvas');
            const container = document.getElementById('hotspot-canvas-container');

            img.src = hotspot.image;
            currentHotspotImage = hotspot.image;

            img.onload = function () {
                canvas.width = img.width;
                canvas.height = img.height;
                container.style.display = 'block';
                document.getElementById('hotspot-types').style.display = 'block';

                // Setup canvas
                setupHotspotCanvas();

                // Recreate existing markers
                hotspotMarkers = [];
                hotspot.markers.forEach(markerData => {
                    const marker = document.createElement('div');
                    marker.className = `hotspot-marker ${markerData.type}`;
                    marker.style.left = markerData.x + 'px';
                    marker.style.top = markerData.y + 'px';
                    marker.innerHTML = markerData.type === 'info' ? 'ℹ️' : '👁️';

                    const markerId = 'marker-' + Date.now() + '-' + Math.random();
                    marker.dataset.markerId = markerId;
                    marker.dataset.type = markerData.type;

                    marker.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openHotspotInfoModalForEdit(markerId, markerData.type, markerData);
                    });

                    container.appendChild(marker);

                    hotspotMarkers.push({
                        id: markerId,
                        x: markerData.x,
                        y: markerData.y,
                        type: markerData.type,
                        text: markerData.text,
                        image: markerData.image
                    });
                });
            };

            // Change the Create button to Update
            const createBtn = modal.querySelector('.btn-save');
            createBtn.textContent = 'Update';
            createBtn.onclick = () => updateHotspotEntity(hotspot);

            modal.classList.add('active');
        }

        function openHotspotInfoModalForEdit(markerId, type, existingData) {
            currentEditingMarker = hotspotMarkers.find(m => m.id === markerId);

            const modal = document.getElementById('hotspot-info-modal');
            const title = document.getElementById('hotspot-info-title');
            const imageSection = document.getElementById('hotspot-image-section');
            const textInput = document.getElementById('hotspot-text-input');

            title.textContent = type === 'info' ? 'Edit Info Hotspot' : 'Edit Eye Hotspot';
            imageSection.style.display = type === 'eye' ? 'block' : 'none';

            if (currentEditingMarker) {
                textInput.value = existingData.text || currentEditingMarker.text || '';

                // Show existing image if present
                if (type === 'eye' && existingData.image) {
                    const preview = document.getElementById('hotspot-image-preview');
                    preview.innerHTML = `<img src="${existingData.image}" style="max-width: 200px; border-radius: 4px;">`;
                }
            }

            modal.classList.add('active');
        }

        function updateHotspotEntity(hotspot) {
            if (!currentHotspotImage || hotspotMarkers.length === 0) {
                showNotification('Please upload an image and add at least one hotspot', 'warning');
                return;
            }

            const hotspotName = document.getElementById('hotspot-name-input')?.value?.trim() || hotspot.name;

            // Get image dimensions from the preview
            const previewImg = document.getElementById('hotspot-preview-image');
            const imgWidth = previewImg.naturalWidth;
            const imgHeight = previewImg.naturalHeight;

            // Update hotspot data
            hotspot.name = hotspotName;
            hotspot.image = currentHotspotImage;
            hotspot.imageWidth = imgWidth;
            hotspot.imageHeight = imgHeight;
            hotspot.markers = JSON.parse(JSON.stringify(hotspotMarkers));

            updateHotspotsList();
            closeHotspotModal();
            showNotification(`Hotspot "${hotspotName}" updated successfully`, 'success');

            // Reset the modal button
            const modal = document.getElementById('hotspot-modal');
            const createBtn = modal.querySelector('.btn-save');
            createBtn.textContent = 'Create';
            createBtn.onclick = createHotspotEntity;
        }

        function createHotspotOverlays(hotspotId, markers) {
            // This creates HTML overlays that follow the 3D plane
            // In a real implementation, you'd sync these with the 3D position
            markers.forEach(marker => {
                console.log('Created hotspot marker:', marker);
                // Implementation would create actual interactive overlays
            });
        }

        function updateHotspotsList() {
            const container = document.getElementById('hotspots-list');

            if (hotspotsList.length === 0) {
                container.innerHTML = '<p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">No hotspots yet. Click "Add Hotspot" to create one.</p>';
                return;
            }

            let html = '';
            hotspotsList.forEach((hotspot, index) => {
                const isSelected = selectedHotspotId === hotspot.id;
                html += `
            <div class="project-list-item ${isSelected ? 'selected' : ''}" 
                onclick="selectHotspot('${hotspot.id}')"
                style="cursor: pointer;">
                <div class="project-name">Image with Hotspots ${index + 1}</div>
                <div class="project-date">${hotspot.markers.length} marker(s)</div>
            </div>
        `;
            });

            container.innerHTML = html;
        }

        function selectHotspot(hotspotId) {
            selectedHotspotId = hotspotId;
            updateHotspotsList();
        }

        function deleteSelectedHotspot() {
            if (!selectedHotspotId) {
                showNotification('Please select a hotspot to delete', 'warning');
                return;
            }

            if (!confirm('Delete this hotspot?')) return;

            // Remove from scene
            const element = document.getElementById(selectedHotspotId);
            if (element) {
                element.parentNode.removeChild(element);
            }

            // Remove from list
            hotspotsList = hotspotsList.filter(h => h.id !== selectedHotspotId);
            selectedHotspotId = null;

            updateHotspotsList();
            showNotification('Hotspot deleted', 'success');
        }

        function createAssetsElement() {
            const scene = document.querySelector('a-scene');
            let assets = scene.querySelector('a-assets');
            if (!assets) {
                assets = document.createElement('a-assets');
                scene.insertBefore(assets, scene.firstChild);
            }
            return assets;
        }


        function editSelectedAnnotation() {
            if (!selectedAnnotationId) {
                showNotification('Please select an annotation to edit', 'warning');
                return;
            }

            openAnnotationModal(true);
        }


        AFRAME.registerComponent('camera-movement-recorder', {
            init: function () {
                this.allRecordings = [];
                this.selectedRecordingIndex = -1;
                this.currentRecording = null;
                this.isRecording = false;
                this.cameraEl = this.el;
                this.startTime = null;
                this.frameCount = 0;
                this.frameRate = 30;
                this.cameraWaypoints = cameraWaypoints; // still using global for manual waypoints

                // ─── Auto recording buttons ────────────────────────────────
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startRecording(document.getElementById('startButton'));
                });
                document.getElementById('endButton').addEventListener('click', () => {
                    this.endRecording(document.getElementById('startButton'));
                });

                // ─── Play current (unsaved) recording + Save current ──
                document.getElementById('play-current-recording-btn')?.addEventListener('click', () => {
                    if (this.currentRecording && this.currentRecording.step_1.position.length > 0) {
                        const animator = this.el.components['camera-movement-animator'];
                        if (animator) {
                            animator.loadRecording(this.currentRecording);
                            animator.startAnimation();
                        }
                    } else {
                        showNotification("No current camera path to play.", "warning");
                    }
                });

                document.getElementById('save-current-as-recording')?.addEventListener('click', () => {
                    this.saveCurrentRecording();
                });

                // ─── Manual waypoints buttons ──────────────────────────────
                document.getElementById('add-keyframe-btn').addEventListener('click', () => {
                    this.addCameraWaypoint();
                });
                document.getElementById('clear-keyframes-btn').addEventListener('click', () => {
                    this.clearCameraWaypoints();
                });
                document.getElementById('play-manual-animation-btn').addEventListener('click', () => {
                    this.playCameraPath();
                });
                document.getElementById('save-manual-as-recording').addEventListener('click', () => {
                    this.saveManualPathAsRecording();
                });

                // ─── Select existing (saved) recording ─────────────────────
                const recordingSelect = document.getElementById('saved-recordings-select');
                recordingSelect.addEventListener('change', (e) => {
                    this.selectedRecordingIndex = parseInt(e.target.value);
                    this.updateRecordingInfo();
                });

                // Play selected saved recording
                document.getElementById('play-saved-recording-btn')?.addEventListener('click', () => {
                    if (this.selectedRecordingIndex >= 0) {
                        this.testAnimation();
                    } else {
                        showNotification("Please select a camera path first.", "warning");
                    }
                });

                // Removed legacy button listener – element no longer exists
                // document.getElementById('testAnimationButton').addEventListener('click', () => {
                //     this.testAnimation();
                // });
            },

            // ─────────────────────────────────────────────────────────────
            // AUTO RECORDING METHODS
            // ─────────────────────────────────────────────────────────────
            startRecording: function (startButton) {
                this.isRecording = true;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.currentRecording = {
                    name: `Temp Recording ${Date.now()}`,
                    step_1: { position: [], rotation: [] }
                };
                const blinkInterval = setInterval(() => {
                    startButton.style.visibility = startButton.style.visibility === 'hidden' ? 'visible' : 'hidden';
                }, 500);
                startButton.dataset.blinkInterval = blinkInterval;
                startButton.textContent = 'Recording...';
                document.getElementById('currentFrame').textContent = '0';
            },

            endRecording: function (startButton) {
                if (!this.isRecording) return;
                this.isRecording = false;
                const endTime = Date.now();
                const duration = (endTime - this.startTime) / 1000;
                this.currentRecording.step_1.frameCount = this.frameCount;
                this.currentRecording.step_1.duration = duration;
                this.currentRecording.step_1.frameRate = this.frameRate;
                clearInterval(startButton.dataset.blinkInterval);
                startButton.style.visibility = 'visible';
                startButton.textContent = 'Start Recording';
                document.getElementById('frameCount').textContent = this.frameCount;
                document.getElementById('duration').textContent = duration.toFixed(2);
                console.log("Recording finished — not auto-added. Click 'Save as Selectable Recording' to keep it.");
            },

            saveCurrentRecording: function () {
                if (!this.currentRecording || this.currentRecording.step_1.position.length === 0) {
                    showNotification("No recording to save yet. Record something first.", "warning");
                    return;
                }

                const defaultName = `Camera path ${this.allRecordings.length + 1}`;
                const self = this;

                showRecordingModal(defaultName, function (name) {
                    self.currentRecording.name = name || defaultName;
                    self.currentRecording.timestamp = new Date().toLocaleString();
                    self.allRecordings.push(self.currentRecording);
                    self.selectedRecordingIndex = self.allRecordings.length - 1;
                    self.updateRecordingSelector();
                    self.updateRecordingInfo();

                    // Also notify scroll-animator if present
                    const scrollEntity = document.querySelector('[scroll-animator]');
                    if (scrollEntity?.components['scroll-animator']) {
                        scrollEntity.components['scroll-animator'].updateRecordingSelector();
                    }

                    // Show success message
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:#28a745;color:white;padding:15px 30px;border-radius:5px;z-index:10001;';
                    overlay.textContent = `Camera path saved as "${self.currentRecording.name}"`;
                    document.body.appendChild(overlay);
                    setTimeout(() => overlay.remove(), 3000);

                    self.currentRecording = null;
                });
            },

            // ─────────────────────────────────────────────────────────────
            // MANUAL WAYPOINTS METHODS
            // ─────────────────────────────────────────────────────────────
            addCameraWaypoint: function () {
                const pos = this.cameraEl.object3D.position;
                const rot = this.cameraEl.object3D.rotation;
                const waypoint = {
                    id: ++waypointCounter,
                    position: [
                        Number(pos.x.toFixed(3)),
                        Number(pos.y.toFixed(3)),
                        Number(pos.z.toFixed(3))
                    ],
                    rotation: [
                        Number(THREE.MathUtils.radToDeg(rot.x).toFixed(2)),
                        Number(THREE.MathUtils.radToDeg(rot.y).toFixed(2)),
                        Number(THREE.MathUtils.radToDeg(rot.z).toFixed(2))
                    ]
                };
                this.cameraWaypoints.push(waypoint);
                this.updateWaypointsListUI();
            },

            clearCameraWaypoints: function () {
                this.cameraWaypoints.length = 0;
                waypointCounter = 0;
                this.updateWaypointsListUI();
            },

            updateWaypointsListUI: function () {
                const container = document.getElementById('keyframes-list');
                if (!container) return;
                if (this.cameraWaypoints.length === 0) {
                    container.innerHTML = '<div style="color:#777; text-align:center; padding:20px 0;">No cameras added yet</div>';
                    return;
                }
                let html = '';
                this.cameraWaypoints.forEach((wp, i) => {
                    html += `
                <div style="padding:10px; margin:6px 0; background:#f0f8ff; border:1px solid #cce5ff; border-radius:6px; font-size:0.95em;">
                    <strong>Camera ${i + 1}</strong><br>
                    <small>Position:</small> ${wp.position.map(v => v.toFixed(2)).join(', ')}<br>
                    <small>Rotation:</small> ${wp.rotation.map(v => v.toFixed(1)).join(', ')}
                </div>
            `;
                });
                container.innerHTML = html;
            },

            playCameraPath: function () {
                if (this.cameraWaypoints.length < 2) {
                    showNotification("Add at least 2 camera positions to create a path.", "warning");
                    return;
                }
                const generated = this.generateInterpolatedRecording("Preview Path");
                const animator = this.el.components['camera-movement-animator'];
                if (animator) {
                    animator.loadRecording(generated);
                    animator.startAnimation();
                }
            },

            saveManualPathAsRecording: function () {
                if (this.cameraWaypoints.length < 2) {
                    showNotification("You need at least 2 cameras to save a recording.", "warning");
                    return;
                }

                const defaultName = `Manual Path ${this.allRecordings.length + 1}`;
                const self = this;

                showRecordingModal(defaultName, function (name) {
                    const recording = self.generateInterpolatedRecording(name || defaultName);
                    recording.timestamp = new Date().toLocaleString();
                    self.allRecordings.push(recording);
                    self.selectedRecordingIndex = self.allRecordings.length - 1;
                    self.updateRecordingSelector();
                    self.updateRecordingInfo();

                    const scrollEntity = document.querySelector('[scroll-animator]');
                    if (scrollEntity?.components['scroll-animator']) {
                        scrollEntity.components['scroll-animator'].updateRecordingSelector();
                    }

                    // Show success message
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:#28a745;color:white;padding:15px 30px;border-radius:5px;z-index:10001;';
                    overlay.textContent = `Camera path saved as "${recording.name}"`;
                    document.body.appendChild(overlay);
                    setTimeout(() => overlay.remove(), 3000);
                });
            },

            generateInterpolatedRecording: function (name) {
                const framesPerSegment = 120;
                const generated = {
                    name: name,
                    step_1: {
                        position: [],
                        rotation: [],
                        frameCount: 0,
                        duration: 0,
                        frameRate: 60
                    }
                };

                for (let i = 0; i < this.cameraWaypoints.length - 1; i++) {
                    const start = this.cameraWaypoints[i];
                    const end = this.cameraWaypoints[i + 1];
                    for (let f = 0; f < framesPerSegment; f++) {
                        const t = f / (framesPerSegment - 1);
                        const pos = [
                            start.position[0] + t * (end.position[0] - start.position[0]),
                            start.position[1] + t * (end.position[1] - start.position[1]),
                            start.position[2] + t * (end.position[2] - start.position[2])
                        ];
                        const rot = [
                            start.rotation[0] + t * (end.rotation[0] - start.rotation[0]),
                            start.rotation[1] + t * (end.rotation[1] - start.rotation[1]),
                            start.rotation[2] + t * (end.rotation[2] - start.rotation[2])
                        ];
                        generated.step_1.position.push(pos.map(v => Number(v.toFixed(3))));
                        generated.step_1.rotation.push(rot.map(v => Number(v.toFixed(2))));
                        generated.step_1.frameCount++;
                    }
                }

                generated.step_1.duration = generated.step_1.frameCount / generated.step_1.frameRate;
                return generated;
            },

            // ─────────────────────────────────────────────────────────────
            // TICK – RECORDING
            // ─────────────────────────────────────────────────────────────
            tick: function () {
                if (!this.isRecording) return;
                let position = this.cameraEl.object3D.position;
                let rotation = this.cameraEl.object3D.rotation;
                let currentData = {
                    position: [position.x.toFixed(2), position.y.toFixed(2), position.z.toFixed(2)],
                    rotation: [
                        THREE.MathUtils.radToDeg(rotation.x).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.y).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.z).toFixed(2)
                    ]
                };
                this.currentRecording.step_1.position.push(currentData.position);
                this.currentRecording.step_1.rotation.push(currentData.rotation);
                this.frameCount++;
                document.getElementById('currentFrame').textContent = this.frameCount;
            },

            // ─────────────────────────────────────────────────────────────
            // SAVED RECORDINGS MANAGEMENT
            // ─────────────────────────────────────────────────────────────
            updateRecordingSelector: function () {
                // ── Changed to target the visible dropdown in "Saved Recordings" section ──
                const select = document.getElementById('saved-recordings-select');

                select.innerHTML = '<option value="">Select a saved camera path...</option>';

                if (this.allRecordings.length === 0) {
                    select.style.display = 'none';
                    return;
                }

                this.allRecordings.forEach((rec, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${rec.name} (${rec.step_1.frameCount} frames, ${rec.step_1.duration?.toFixed(2) || '?'}s)`;
                    select.appendChild(option);
                });

                select.value = this.selectedRecordingIndex;
                select.style.display = 'block';
            },

            updateRecordingInfo: function () {
                if (this.selectedRecordingIndex < 0 || this.selectedRecordingIndex >= this.allRecordings.length) return;
                const rec = this.allRecordings[this.selectedRecordingIndex];
                document.getElementById('frameCount').textContent = rec.step_1.frameCount;
                document.getElementById('duration').textContent = rec.step_1.duration.toFixed(2);
            },

            testAnimation: function () {
                if (this.selectedRecordingIndex < 0 || this.selectedRecordingIndex >= this.allRecordings.length) {
                    showNotification("No recording selected.", "warning");
                    return;
                }
                const recording = this.allRecordings[this.selectedRecordingIndex];
                const animator = this.el.components['camera-movement-animator'];
                if (animator) {
                    animator.loadRecording(recording);
                    animator.startAnimation();
                }
            }
        });

        AFRAME.registerComponent('camera-movement-animator', {
            schema: { type: 'string' },
            init: function () {
                this.animationData = null;
                this.steps = [];
                this.currentStepIndex = 0;
                this.currentIndex = 0;
                this.startTime = null;
                this.frameRate = 30;
                this.isAnimating = false; // Add this flag

                const speedSlider = document.getElementById('camera-speed');
                const speedValue = document.getElementById('camera-speed-value');
                const wasdEntity = document.querySelector('a-entity[wasd-controls]');
                if (speedSlider && speedValue && wasdEntity) {
                    speedValue.textContent = speedSlider.value;
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseFloat(event.target.value);
                        speedValue.textContent = speed;
                        wasdEntity.setAttribute('wasd-controls', 'acceleration', speed);
                    });
                }
            },
            loadRecording: function (recording) {
                this.animationData = recording;
                this.steps = Object.keys(this.animationData).filter(key => key.startsWith('step_'));
                this.currentStepIndex = 0;
                this.currentIndex = 0;
            },
            startAnimation: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.isAnimating = true;
                this.el.removeAttribute('look-controls');
                this.startTime = Date.now();
                this.animateStep();
            },
            stopAnimation: function () {
                this.isAnimating = false;
                this.el.setAttribute('look-controls', '');
            },
            animateStep: function () {
                if (!this.isAnimating || this.currentStepIndex >= this.steps.length) {
                    this.stopAnimation(); // Restore controls when done
                    return;
                }

                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];
                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;
                    setTimeout(() => this.animateStep(), 100);
                    return;
                }
                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];
                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);
                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);
                const currentFrame = this.currentIndex + 1;
                document.getElementById('currentFrame').textContent = currentFrame;
                this.currentIndex++;
                setTimeout(() => this.animateStep(), 1000 / this.frameRate);
            }
        });

        AFRAME.registerComponent('scroll-animator', {
            schema: {
                speed: { type: 'number', default: 1 },
                direction: { type: 'string', default: 'bottom-to-center' }
            },
            init: function () {
                this.textOverlays = [];
                this.currentTextIndex = 0;
                this.textDisplayRange = 10;
                this.animationData = null;
                this.steps = [];
                this.currentStepIndex = 0;
                this.currentIndex = 0;
                this.currentRecordingIndex = -1;
                this.recordingTextSlides = {}; // Store slides per recording: { recordingIndex: [slides] }

                const recordingSelectScroll = document.getElementById('recording-select-scroll');
                recordingSelectScroll.addEventListener('change', (e) => {
                    const newIndex = parseInt(e.target.value);

                    // ─── Important: save slides of PREVIOUS recording first ───
                    if (this.currentRecordingIndex >= 0 &&
                        this.currentRecordingIndex !== newIndex) {
                        this.autoSaveCurrentSlides();
                    }
                    this.loadRecording(newIndex);
                    this.loadTextSlidesForRecording(newIndex);
                });
                const speedSlider = document.getElementById('speed-slider');
                const speedValue = document.querySelector('.speed-value');
                if (speedSlider && speedValue) {
                    speedValue.textContent = this.data.speed;
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseInt(event.target.value, 10);
                        speedValue.textContent = speed;
                        this.el.setAttribute('scroll-animator', 'speed', speed);
                    });
                }
                document.getElementById('add-slide-button').addEventListener('click', () => {
                    openAddSlideModal();
                });
                const frameSlider = document.getElementById('frame-slider');
                const frameSliderValue = document.getElementById('frame-slider-value');
                if (frameSlider && frameSliderValue) {
                    frameSlider.addEventListener('input', (event) => {
                        const frame = parseInt(event.target.value, 10);
                        frameSliderValue.textContent = frame;
                        this.jumpToFrame(frame);
                    });
                }
                const directionSelect = document.getElementById('direction-select');
                if (directionSelect) {
                    directionSelect.addEventListener('change', (event) => {
                        const direction = event.target.value;
                        this.el.setAttribute('scroll-animator', 'direction', direction);
                    });
                }
                // ADD THESE NEW EVENT LISTENERS
                const bgColorInput = document.getElementById('overlay-bg-color');
                const bgOpacityInput = document.getElementById('overlay-bg-opacity');
                const widthSlider = document.getElementById('overlay-width-slider');
                const widthValue = document.getElementById('overlay-width-value');

                if (bgColorInput) {
                    bgColorInput.addEventListener('change', (event) => {
                        this.overlayBgColor = event.target.value;
                        this.updateOverlayStyles();
                    });
                }

                if (bgOpacityInput) {
                    bgOpacityInput.addEventListener('input', (event) => {
                        this.overlayBgOpacity = parseInt(event.target.value, 10) / 100;
                        this.updateOverlayStyles();
                    });
                }

                if (widthSlider) {
                    widthSlider.addEventListener('input', (event) => {
                        this.overlayWidth = parseInt(event.target.value, 10);
                        widthValue.textContent = this.overlayWidth;
                        this.updateOverlayStyles();
                    });
                }

                // Initialize default values
                this.overlayBgColor = '#ffffff';
                this.overlayBgOpacity = 0.95;
                this.overlayWidth = 80;


                this.updateRecordingSelector();



            },
            loadTextSlidesForRecording: function (recordingIndex) {
                this.currentRecordingIndex = recordingIndex;
                const container = document.querySelector('.text-inputs-container');

                // Clear existing slides
                container.innerHTML = '';

                // Load slides for this recording if they exist
                const slides = this.recordingTextSlides[recordingIndex] || [];

                if (slides.length === 0) {
                    const noSlidesMsg = document.createElement('p');
                    noSlidesMsg.style.cssText = 'color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;';
                    noSlidesMsg.textContent = 'No slides added yet. Click "Add Slide" to create text overlays.';
                    container.appendChild(noSlidesMsg);
                } else {
                    // Recreate slides from saved data
                    slides.forEach((slideData, index) => {
                        this.recreateTextSlide(slideData, index + 1);
                    });
                }
            },

            recreateTextSlide: function (slideData, slideNumber) {
                const container = document.querySelector('.text-inputs-container');
                const noSlidesMsg = container.querySelector('p[style*="color: #a0aec0"]');
                if (noSlidesMsg) {
                    noSlidesMsg.remove();
                }

                const editorId = 'editor-' + Date.now() + '-' + Math.floor(Math.random() * 100000000);
                const newTextInput = document.createElement('div');
                newTextInput.className = 'text-input-row';
                newTextInput.innerHTML = `
                <label class="slideTitle">Slide: ${slideNumber}</label>
                <input type="number" class="frameNumber" placeholder="Frame number..." value="${slideData.frameNumber || ''}">
                <input type="number" class="durationFrames" placeholder="Duration in frames..." min="1" value="${slideData.durationFrames || ''}">
                <div class="quill-editor-container">
                    <div id="${editorId}" class="scrollableText"></div>
                </div>
                <button class="delete-slide-button">Delete</button>
            `;
                container.appendChild(newTextInput);

                // Initialize Quill editor
                const quill = new Quill('#' + editorId, {
                    theme: 'snow',
                    placeholder: 'Enter text...',
                    modules: {
                        toolbar: [
                            ['bold', 'italic', 'underline'],
                            [{ 'color': [] }, { 'background': [] }],
                            [{ 'align': [] }],
                            ['image'],
                            ['clean']
                        ]
                    }
                });

                // Set the content
                quill.root.innerHTML = slideData.text || '';

                // Store quill instance
                newTextInput.querySelector('.quill-editor-container').quillInstance = quill;

                const deleteButton = newTextInput.querySelector('.delete-slide-button');
                deleteButton.addEventListener('click', () => {
                    this.deleteSlide(newTextInput);
                });
                const frameNumberInput = newTextInput.querySelector('.frameNumber');
                const durationInput = newTextInput.querySelector('.durationFrames');

                frameNumberInput.addEventListener('input', () => {
                    this.autoSaveCurrentSlides();
                });

                durationInput.addEventListener('input', () => {
                    this.autoSaveCurrentSlides();
                });

                // Auto-save when text content changes
                quill.on('text-change', () => {
                    this.autoSaveCurrentSlides();
                });

                // Auto-save slides whenever they're modified
                this.autoSaveCurrentSlides();
            },
            updateRecordingSelector: function () {
                const cameraEntity = document.querySelector('[camera-movement-recorder]');
                const recordingSelectScroll = document.getElementById('recording-select-scroll');
                if (!cameraEntity || !cameraEntity.components['camera-movement-recorder']) return;
                const allRecordings = cameraEntity.components['camera-movement-recorder'].allRecordings;
                recordingSelectScroll.innerHTML = '<option value="">Select a camera path...</option>';
                allRecordings.forEach((recording, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${recording.name} (${recording.step_1.frameCount} frames)`;
                    recordingSelectScroll.appendChild(option);
                });
                if (allRecordings.length > 0) {
                    recordingSelectScroll.style.display = 'block';
                    document.querySelector('label[for="recording-select-scroll"]').style.display = 'block';
                }
            },

            loadRecording: function (recordingIndex) {
                const cameraEntity = document.querySelector('[camera-movement-recorder]');
                if (!cameraEntity || !cameraEntity.components['camera-movement-recorder']) return;
                const allRecordings = cameraEntity.components['camera-movement-recorder'].allRecordings;
                if (recordingIndex === '' || recordingIndex < 0 || recordingIndex >= allRecordings.length) {
                    this.animationData = null;
                    this.steps = [];
                    return;
                }
                const recording = allRecordings[recordingIndex];
                this.animationData = recording;
                this.steps = Object.keys(this.animationData).filter(key => key.startsWith('step_'));
                this.currentStepIndex = 0;
                this.currentIndex = 0;
                const stepKey = this.steps[0];
                const frameCount = this.animationData[stepKey].frameCount;
                const duration = this.animationData[stepKey].duration;
                document.querySelector('#frameCount2').textContent = frameCount;
                document.querySelector('#duration2').textContent = duration.toFixed(2);
                const frameSlider = document.getElementById('frame-slider');
                const frameSliderValue = document.getElementById('frame-slider-value');
                if (frameSlider && frameSliderValue) {
                    frameSlider.max = frameCount - 1;
                    frameSlider.value = 0;
                    frameSliderValue.textContent = 0;
                }
                this.setupScrollListener();
            },
            addTextInput: function () {
                if (this.currentRecordingIndex < 0) {
                    showNotification('Please select a camera path first before adding slides.', 'warning');
                    return;
                }

                const container = document.querySelector('.text-inputs-container');

                // Remove the "no slides" message if it exists
                const noSlidesMsg = container.querySelector('p[style*="color: #a0aec0"]');
                if (noSlidesMsg) {
                    noSlidesMsg.remove();
                }

                const slideCount = container.querySelectorAll('.text-input-row').length + 1;
                const editorId = 'editor-' + Date.now();

                const newTextInput = document.createElement('div');
                newTextInput.className = 'text-input-row';
                newTextInput.innerHTML = `
            <label class="slideTitle">Slide: ${slideCount}</label>
            <input type="number" class="frameNumber" placeholder="Frame number...">
            <input type="number" class="durationFrames" placeholder="Duration in frames..." min="1">
            <div class="quill-editor-container">
                <div id="${editorId}" class="scrollableText"></div>
            </div>
            <button class="delete-slide-button">Delete</button>
            `;
                container.appendChild(newTextInput);

                const quill = new Quill('#' + editorId, {
                    theme: 'snow',
                    placeholder: 'Enter text...',
                    modules: {
                        toolbar: [
                            ['bold', 'italic', 'underline'],
                            [{ 'color': [] }, { 'background': [] }],
                            [{ 'align': [] }],
                            ['image'],
                            ['clean']
                        ]
                    }
                });

                newTextInput.querySelector('.quill-editor-container').quillInstance = quill;

                const deleteButton = newTextInput.querySelector('.delete-slide-button');
                deleteButton.addEventListener('click', () => {
                    this.deleteSlide(newTextInput);
                });

                // Auto-save slides whenever they're modified
                this.autoSaveCurrentSlides();
            },
            autoSaveCurrentSlides: function () {
                if (this.currentRecordingIndex < 0) return;

                const slides = [];
                document.querySelectorAll('.text-input-row').forEach(row => {
                    const editorContainer = row.querySelector('.quill-editor-container');
                    const quill = editorContainer ? editorContainer.quillInstance : null;
                    const textContent = quill ? quill.root.innerHTML : '';

                    slides.push({
                        text: textContent,
                        frameNumber: parseInt(row.querySelector('.frameNumber').value, 10) || 0,
                        durationFrames: parseInt(row.querySelector('.durationFrames').value, 10) || 0
                    });
                });

                this.recordingTextSlides[this.currentRecordingIndex] = slides;
            },
            deleteSlide: function (slideElement) {
                const container = document.querySelector('.text-inputs-container');
                container.removeChild(slideElement);
                const slides = container.querySelectorAll('.text-input-row');
                slides.forEach((slide, index) => {
                    const slideTitle = slide.querySelector('.slideTitle');
                    slideTitle.textContent = `Slide: ${index + 1}`;
                });

                // If no slides left, show the "no slides" message
                if (slides.length === 0) {
                    const noSlidesMsg = document.createElement('p');
                    noSlidesMsg.style.cssText = 'color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;';
                    noSlidesMsg.textContent = 'No slides added yet. Click "Add Slide" to create text overlays.';
                    container.appendChild(noSlidesMsg);
                }

                // Auto-save after deletion
                this.autoSaveCurrentSlides();
            },
            setupScrollListener: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.el.removeAttribute('look-controls');
                window.addEventListener('wheel', (event) => {
                    if (event.deltaY > 0) {
                        this.nextFrame();
                    } else {
                        this.previousFrame();
                    }
                });
            },
            nextFrame: function () {
                if (!this.animationData || this.steps.length === 0) return;
                if (this.currentStepIndex >= this.steps.length - 1 && this.currentIndex >= this.animationData[this.steps[this.currentStepIndex]].position.length - 1) {
                    console.log("Reached the end of the animation.");
                    return;
                }
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }
                this.currentIndex += this.data.speed;
                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;
                    if (this.currentStepIndex >= this.steps.length) {
                        this.currentStepIndex = this.steps.length - 1;
                        this.currentIndex = stepData.position.length - 1;
                        console.log("Reached the end of the animation.");
                        return;
                    }
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                }
                this.updateCameraPosition(stepData);
                this.updateTextOverlay();
            },
            previousFrame: function () {
                if (!this.animationData || this.steps.length === 0) return;
                if (this.currentStepIndex <= 0 && this.currentIndex <= 0) {
                    console.log("Reached the beginning of the animation.");
                    return;
                }
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }
                this.currentIndex -= this.data.speed;
                if (this.currentIndex < 0) {
                    this.currentStepIndex--;
                    this.currentIndex = 0;
                    if (this.currentStepIndex < 0) {
                        this.currentStepIndex = 0;
                        this.currentIndex = 0;
                        console.log("Reached the beginning of the animation.");
                        return;
                    }
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                    this.currentIndex = stepData.position.length - 1;
                }
                this.updateCameraPosition(stepData);
                this.updateTextOverlay();
            },
            jumpToFrame: function (frame) {
                if (!this.animationData || this.steps.length === 0) return;
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];
                if (frame >= 0 && frame < stepData.position.length) {
                    this.currentIndex = frame;
                    this.updateCameraPosition(stepData);
                    this.updateTextOverlay();
                }
            },
            updateCameraPosition: function (stepData) {
                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];
                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);
                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);
                const currentFrame = this.currentIndex + 1;
                document.querySelector('#currentFrame2').textContent = currentFrame;
                const frameSlider = document.getElementById('frame-slider');
                const frameSliderValue = document.getElementById('frame-slider-value');
                if (frameSlider && frameSliderValue) {
                    frameSlider.value = this.currentIndex;
                    frameSliderValue.textContent = this.currentIndex;
                }
            },
            updateTextOverlay: function () {
                const currentFrame = this.currentIndex + 1;
                const textInputs = document.querySelectorAll('.text-input-row');
                let foundText = false;
                textInputs.forEach((inputRow, index) => {
                    const frameNumberInput = inputRow.querySelector('.frameNumber');
                    const editorContainer = inputRow.querySelector('.quill-editor-container');
                    const durationInput = inputRow.querySelector('.durationFrames');

                    // Get Quill instance and HTML content
                    const quill = editorContainer ? editorContainer.quillInstance : null;
                    const textContent = quill ? quill.root.innerHTML : '';

                    const frameNumber = parseInt(frameNumberInput.value, 10);
                    const durationFrames = parseInt(durationInput.value, 10);
                    const startFrame = frameNumber - this.textDisplayRange;
                    const endFrame = frameNumber + durationFrames + this.textDisplayRange;
                    if (currentFrame >= startFrame && currentFrame <= endFrame) {
                        const progress = this.calculateProgress(currentFrame, frameNumber, durationFrames);
                        this.showTextOverlay(textContent, progress);
                        foundText = true;
                    }
                });
                if (!foundText) {
                    this.hideTextOverlay();
                }
            },

            calculateProgress: function (currentFrame, targetFrame, durationFrames) {
                const fadeInDuration = this.textDisplayRange;
                const fadeOutDuration = this.textDisplayRange;
                const fadeOutStart = targetFrame + durationFrames;
                if (currentFrame < targetFrame) {
                    return 0.5 * (currentFrame - (targetFrame - fadeInDuration)) / fadeInDuration;
                } else if (currentFrame >= targetFrame && currentFrame < fadeOutStart) {
                    return 1;
                } else if (currentFrame >= fadeOutStart && currentFrame <= fadeOutStart + fadeOutDuration) {
                    return 1 + 0.5 * ((currentFrame - fadeOutStart) / fadeOutDuration);
                } else {
                    return 0;
                }
            },
            showTextOverlay: function (text, progress) {
                let textOverlay = document.querySelector('.text-overlay');
                if (!textOverlay) {
                    textOverlay = document.createElement('div');
                    textOverlay.className = 'text-overlay';
                    document.body.appendChild(textOverlay);
                }
                textOverlay.innerHTML = text;

                // Apply custom background and width
                const hex = this.overlayBgColor.replace('#', '');
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);

                textOverlay.style.background = `rgba(${r}, ${g}, ${b}, ${this.overlayBgOpacity})`;
                textOverlay.style.maxWidth = `${this.overlayWidth}%`;

                let opacity, position;
                if (progress < 0.5) {
                    opacity = progress * 2;
                    position = this.calculateStartPosition(progress * 2);
                } else if (progress >= 0.5 && progress <= 1) {
                    opacity = 1;
                    position = { left: '50%', top: '50%', transform: 'translate(-50%, -50%)' };
                } else if (progress > 1 && progress <= 1.5) {
                    opacity = 1 - ((progress - 1) * 2);
                    position = this.calculateEndPosition((progress - 1) * 2);
                } else {
                    opacity = 0;
                    position = this.calculateEndPosition(1);
                }
                textOverlay.style.opacity = opacity;
                textOverlay.style.left = position.left;
                textOverlay.style.top = position.top;
                textOverlay.style.transform = position.transform;
            },
            updateOverlayStyles: function () {
                const textOverlay = document.querySelector('.text-overlay');
                if (textOverlay) {
                    // Convert hex color to RGB
                    const hex = this.overlayBgColor.replace('#', '');
                    const r = parseInt(hex.substring(0, 2), 16);
                    const g = parseInt(hex.substring(2, 4), 16);
                    const b = parseInt(hex.substring(4, 6), 16);

                    textOverlay.style.background = `rgba(${r}, ${g}, ${b}, ${this.overlayBgOpacity})`;
                    textOverlay.style.maxWidth = `${this.overlayWidth}%`;
                }
            },
            calculateStartPosition: function (progress) {
                const direction = this.data.direction;
                switch (direction) {
                    case 'bottom-to-center':
                        return { left: '50%', top: `${100 - (progress * 50)}%`, transform: 'translate(-50%, -50%)' };
                    case 'left-to-center':
                        return { left: `${progress * 50}%`, top: '50%', transform: 'translate(-50%, -50%)' };
                    case 'right-to-center':
                        return { left: `${100 - (progress * 50)}%`, top: '50%', transform: 'translate(-50%, -50%)' };
                    case 'top-to-center':
                        return { left: '50%', top: `${progress * 50}%`, transform: 'translate(-50%, -50%)' };
                    default:
                        return { left: '50%', top: '50%', transform: 'translate(-50%, -50%)' };
                }
            },
            calculateEndPosition: function (progress) {
                const direction = this.data.direction;
                switch (direction) {
                    case 'bottom-to-center':
                        return { left: '50%', top: `${50 - (progress * 50)}%`, transform: 'translate(-50%, -50%)' };
                    case 'left-to-center':
                        return { left: `${50 + (progress * 50)}%`, top: '50%', transform: 'translate(-50%, -50%)' };
                    case 'right-to-center':
                        return { left: `${50 - (progress * 50)}%`, top: '50%', transform: 'translate(-50%, -50%)' };
                    case 'top-to-center':
                        return { left: '50%', top: `${50 + (progress * 50)}%`, transform: 'translate(-50%, -50%)' };
                    default:
                        return { left: '50%', top: '50%', transform: 'translate(-50%, -50%)' };
                }
            },
            hideTextOverlay: function () {
                const textOverlay = document.querySelector('.text-overlay');
                if (textOverlay) {
                    textOverlay.style.opacity = 0;
                    textOverlay.style.left = '50%';
                    textOverlay.style.top = '100%';
                    textOverlay.style.transform = 'translate(-50%, -50%)';
                }
            }
        });

        function togglePanel(panelId) {
            const translate = document.getElementById('translateIcon');
            const rotate = document.getElementById('rotateIcon');
            const scale = document.getElementById('scaleIcon');
            const wasd = document.getElementById('wasd');
            const fly = document.getElementById('fly');
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => {
                panel.style.display = panel.id === panelId ?
                    (panel.style.display === 'block' ? 'none' : 'block') :
                    'none';
            });
            const cameras = document.querySelectorAll('[camera]');
            if (cameras.length >= 2) {
                let isActive = cameras[1].getAttribute('camera').active === 'true';
                if (panelId === "camera-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');
                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "scroll-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');
                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "effects-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');
                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "save-load-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');
                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "scene-elements-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                    window.setTimeout(() => {
                        new Editor();
                    }, 100);
                }
                else if (panelId === "hotspots-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                    window.setTimeout(() => {
                        new Editor();
                    }, 100);
                }
                else if (panelId === "videos-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                }
                else if (panelId === "audio-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');
                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";

                    // Load voices when panel opens
                    loadVoicesForAudioPanel();
                }
                else if (panelId === "article-structure-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');
                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
            }
        }

        let splatEntityId = 0;

        document.addEventListener('DOMContentLoaded', function () {
            // Helper function to create assets element if it doesn't exist
            function createAssetsElement() {
                const scene = document.querySelector('a-scene');
                let assets = document.createElement('a-assets');
                scene.insertBefore(assets, scene.firstChild);
                return assets;
            }

            // Unified asset loader for both 3D models and images
            let assetInput = document.getElementById('asset-loader');
            assetInput.addEventListener('change', function (event) {
                const files = event.target.files;
                if (files.length > 0) {
                    Array.from(files).forEach(file => {
                        const url = URL.createObjectURL(file);
                        const fileName = file.name.toLowerCase();

                        // Check if it's an image file
                        if (fileName.match(/\.(jpg|jpeg|png|gif|webp)$/)) {
                            // Handle image upload
                            const assetId = 'img-' + Date.now() + '-' + Math.floor(Math.random() * 1000000);

                            // Add image to assets
                            const assets = document.querySelector('a-assets') || createAssetsElement();
                            const imgAsset = document.createElement('img');
                            imgAsset.setAttribute('id', assetId);
                            imgAsset.setAttribute('src', url);
                            imgAsset.setAttribute('crossorigin', 'anonymous');
                            assets.appendChild(imgAsset);

                            // Create a plane with the image as texture
                            const imagePlane = document.createElement('a-plane');
                            imagePlane.setAttribute('position', '0 1.6 -3');
                            imagePlane.setAttribute('rotation', '0 0 0');
                            imagePlane.setAttribute('width', '2');
                            imagePlane.setAttribute('height', '2');
                            imagePlane.setAttribute('material', {
                                src: '#' + assetId,
                                side: 'double',
                                transparent: true,
                                shader: 'flat'
                            });

                            document.querySelector("a-scene").appendChild(imagePlane);

                            // Wait for image to load to get aspect ratio
                            imgAsset.addEventListener('load', function () {
                                const aspectRatio = imgAsset.naturalWidth / imgAsset.naturalHeight;
                                const height = 2;
                                const width = height * aspectRatio;
                                imagePlane.setAttribute('width', width);
                                imagePlane.setAttribute('height', height);
                            });

                            window.setTimeout(() => {
                                new Editor();
                            }, 100);

                        } else if (fileName.endsWith('.splat')) {
                            // Handle Gaussian Splat upload
                            splatEntityId++;
                            const splatEntity = document.createElement('a-entity');
                            let modelContainer = document.createElement('a-entity');
                            modelContainer.id = `splat${splatEntityId}`;
                            modelContainer.setAttribute('geometry', {
                                primitive: 'box',
                                width: 5,
                                height: 5,
                                depth: 5
                            });
                            modelContainer.setAttribute('material', {
                                color: 'white',
                                wireframe: true,
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.1,
                                toneMapped: false,
                                visible: false
                            });
                            document.querySelector('a-scene').appendChild(modelContainer);
                            modelContainer.appendChild(splatEntity);
                            splatEntity.setAttribute('gaussian-splatting', `src: ${url};`);

                            document.addEventListener("objectPositionUpdate", (event) => {
                                const { id, x, y, z } = event.detail;
                                const modelContainer = document.getElementById(id);
                                if (modelContainer) {
                                    const splatEntity = modelContainer.querySelector('[gaussian-splatting]');
                                    if (splatEntity) {
                                        splatEntity.setAttribute('position', { x, y, z });
                                    }
                                }
                            });

                            document.addEventListener("objectRotationUpdate", (event) => {
                                const { id, x, y, z } = event.detail;
                                const modelContainer = document.getElementById(id);
                                if (modelContainer) {
                                    const splatEntity = modelContainer.querySelector('[gaussian-splatting]');
                                    if (splatEntity) {
                                        splatEntity.setAttribute('rotation', { x, y, z });
                                    }
                                }
                            });

                            window.setTimeout(() => {
                                new Editor();
                            }, 100);

                        } else {
                            // Handle GLTF/GLB upload
                            const model = document.createElement('a-entity');
                            model.setAttribute('gltf-model', `url(${url})`);
                            model.setAttribute('scale', '1 1 1');
                            document.querySelector("a-scene").appendChild(model);

                            model.addEventListener('model-loaded', function (event) {
                                window.setTimeout(() => {
                                    new Editor();
                                }, 100);
                            });
                        }
                    });
                }
            });

            document.querySelector("#wasd").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", false);
                }
            });
            document.querySelector("#fly").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", true);
                }
            });


            // Grid Toggle Functionality
            const gridToggleButton = document.getElementById('gridToggle');
            const gridIcon = document.getElementById('gridIcon');
            let gridElement = document.querySelector("a-grid");
            let gridEnabled = true; // Grid starts enabled by default

            gridToggleButton.addEventListener("click", function () {
                if (gridEnabled) {
                    // Disable grid
                    if (gridElement) {
                        document.querySelector('a-scene').removeChild(gridElement);
                        gridElement = null;
                    }
                    gridIcon.src = "icons/grid-disable.png";
                    gridToggleButton.classList.remove('active');
                    gridToggleButton.title = "Enable Grid";
                    gridEnabled = false;
                } else {
                    // Enable grid
                    if (!gridElement) {
                        gridElement = document.createElement('a-grid');
                        gridElement.setAttribute('position', '0 -0.1 0');
                        document.querySelector('a-scene').appendChild(gridElement);
                    }
                    gridIcon.src = "icons/grid-enable.png";
                    gridToggleButton.classList.add('active');
                    gridToggleButton.title = "Disable Grid";
                    gridEnabled = true;
                }
            });

            // Set initial state
            if (gridEnabled) {
                gridToggleButton.classList.add('active');
            }

            document.getElementById('effect-select').addEventListener('change', function () {
                const selectedEffect = this.value;
                const scene = document.querySelector("a-scene");
                scene.setAttribute("post-processing", "effect", selectedEffect);
            });
            const speedSlider = document.getElementById('camera-speed');
            const speedValue = document.getElementById('camera-speed-value');
            const wasdEntity = document.querySelector('a-entity[wasd-controls]');
            if (speedSlider && speedValue && wasdEntity) {
                speedValue.textContent = speedSlider.value;
                speedSlider.addEventListener('input', (event) => {
                    const speed = parseFloat(event.target.value);
                    speedValue.textContent = speed;
                    wasdEntity.setAttribute('wasd-controls', 'acceleration', speed);
                });
            }
            document.getElementById('preloadGS').addEventListener('click', function () {
                const url = 'truck.splat';
                const splatEntity = document.createElement('a-entity');
                let modelContainer = document.createElement('a-entity');
                modelContainer.id = `splat${splatEntityId}`;
                modelContainer.setAttribute('geometry', {
                    primitive: 'box',
                    width: 5,
                    height: 5,
                    depth: 5
                });
                modelContainer.setAttribute('material', {
                    color: 'white',
                    wireframe: true,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.1,
                    toneMapped: false,
                    visible: false
                });
                document.querySelector('a-scene').appendChild(modelContainer);
                modelContainer.appendChild(splatEntity);
                splatEntity.setAttribute('gaussian-splatting', `src: ${url};`);
                document.addEventListener("objectPositionUpdate", (event) => {
                    const { id, x, y, z } = event.detail;
                    const modelContainer = document.getElementById(id);
                    if (modelContainer) {
                        const splatEntity = modelContainer.querySelector('[gaussian-splatting]');
                        if (splatEntity) {
                            splatEntity.setAttribute('position', { x, y, z });
                        }
                    }
                });
                document.addEventListener("objectRotationUpdate", (event) => {
                    const { id, x, y, z } = event.detail;
                    const modelContainer = document.getElementById(id);
                    if (modelContainer) {
                        const splatEntity = modelContainer.querySelector('[gaussian-splatting]');
                        if (splatEntity) {
                            splatEntity.setAttribute('rotation', { x, y, z });
                        }
                    }
                });
                console.log('Loading .splat file:', url);
                window.setTimeout(() => {
                    new Editor();
                }, 100);
            });
            document.getElementById('preloadGLTF').addEventListener('click', function () {
                const url = 'foresthouse.glb';
                const model = document.createElement('a-entity');
                model.setAttribute('gltf-model', `url(${url})`);
                model.setAttribute('scale', '1 1 1');
                document.querySelector("a-scene").appendChild(model);
                console.log('Loading .gltf file:', url);

                model.addEventListener('model-loaded', function (event) {
                    window.setTimeout(() => {
                        new Editor();
                    }, 100);
                })
            });
            document.getElementById("backgroundChange").addEventListener("click", function () {
                let colorPicker = document.getElementById("colorPicker");
                if (!colorPicker) {
                    colorPicker = document.createElement("input");
                    colorPicker.type = "color";
                    colorPicker.id = "colorPicker";
                    colorPicker.style.position = "absolute";
                    colorPicker.style.top = "50px";
                    colorPicker.style.right = "50px";
                    colorPicker.style.opacity = "0";
                    colorPicker.style.pointerEvents = "none";
                    document.body.appendChild(colorPicker);
                }
                setTimeout(() => {
                    colorPicker.click();
                }, 10);
                colorPicker.addEventListener("input", function () {
                    let sky = document.querySelector("a-sky");
                    if (sky) {
                        sky.setAttribute("color", colorPicker.value);
                    }
                });
            });
        });

        AFRAME.registerPrimitive("a-grid", {
            defaultComponents: {
                geometry: {
                    primitive: "plane",
                    width: 75,
                    height: 75,
                },
                rotation: { x: -90, y: 0, z: 0 },
                material: {
                    src: "https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v1.16.3/assets/grid.png",
                    repeat: "75 75",
                },
            },
            mappings: {
                width: "geometry.width",
                height: "geometry.height",
                src: "material.src",
            },
        });

        document.addEventListener('DOMContentLoaded', function () {
            const colorEffectDropdown = document.getElementById('colorEffect');
            const singleColorPicker = document.getElementById('singleColor');
            const displayRadiusSlider = document.getElementById('displayRadius');
            const displayRadiusValue = document.getElementById('displayRadiusValue');
            if (colorEffectDropdown && singleColorPicker && displayRadiusSlider && displayRadiusValue) {
                colorEffectDropdown.addEventListener('change', function () {
                    const effect = parseInt(this.value, 10);
                    const splatEntity = document.querySelector('[gaussian-splatting]');
                    if (splatEntity) {
                        console.log('Setting color effect:', effect);
                        splatEntity.components['gaussian-splatting'].setColorEffect(effect);
                        splatEntity.sceneEl.renderer.render(splatEntity.sceneEl.object3D, splatEntity.sceneEl.camera);
                    }
                });
                singleColorPicker.addEventListener('change', function () {
                    const color = this.value;
                    const splatEntity = document.querySelector('[gaussian-splatting]');
                    if (splatEntity) {
                        console.log('Setting single color:', color);
                        splatEntity.components['gaussian-splatting'].setSingleColor(color);
                        splatEntity.sceneEl.renderer.render(splatEntity.sceneEl.object3D, splatEntity.sceneEl.camera);
                    }
                });
                displayRadiusSlider.addEventListener('input', function () {
                    const radius = parseFloat(this.value);
                    displayRadiusValue.textContent = radius.toFixed(1);
                    const splatEntity = document.querySelector('[gaussian-splatting]');
                    if (splatEntity) {
                        console.log('Setting display radius:', radius);
                        splatEntity.components['gaussian-splatting'].setDisplayRadius({ x: radius, y: radius, z: radius });
                        splatEntity.sceneEl.renderer.render(splatEntity.sceneEl.object3D, splatEntity.sceneEl.camera);
                    }
                });
            } else {
                console.error('One or more elements not found in the DOM.');
            }
        });

        function downloadHTML() {
            const recordingSelectScroll = document.getElementById('recording-select-scroll');
            const selectedRecordingIndex = recordingSelectScroll ? parseInt(recordingSelectScroll.value) : null;

            if (!selectedRecordingIndex && selectedRecordingIndex !== 0) {
                showNotification('Please select a camera path in the Text Slides panel before exporting.', 'warning');
                return;
            }

            const scene = document.querySelector('a-scene');
            scene.flushToDOM(true);
            const sceneContent = scene.innerHTML;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = sceneContent;
            const cameraEntities = tempDiv.querySelectorAll('[camera-movement-recorder], [camera-movement-animator], [scroll-animator], [wasd-controls], [look-controls], [tooltip-component]');
            cameraEntities.forEach(el => el.remove());
            // Also remove canvas and injected elements
            const canvases = tempDiv.querySelectorAll('canvas, .a-loader-title, [aframe-injected], .myCam');
            canvases.forEach(el => el.remove());
            const filteredSceneContent = tempDiv.innerHTML;

            const postProcessing = scene.getAttribute('post-processing');
            const currentEffect = postProcessing ? postProcessing.effect : 'none';
            const sky = scene.querySelector('a-sky');
            const skyColor = sky ? sky.getAttribute('color') : '#000000';
            const hasGaussianSplats = scene.querySelectorAll('[gaussian-splatting]').length > 0;

            // GET PROJECT NAME FOR TITLE - MOVE THIS UP BEFORE exportedHTML
            // GET EXPORT NAME FOR TITLE AND FILENAME

            const exportName = document.getElementById('export-scene-name-input')?.value?.trim() || 'my-3d-scene';
            const projectName = exportName;

            const textSlides = [];
            document.querySelectorAll('.text-input-row').forEach(row => {
                const editorContainer = row.querySelector('.quill-editor-container');
                const quill = editorContainer ? editorContainer.quillInstance : null;
                const textContent = quill ? quill.root.innerHTML : '';

                textSlides.push({
                    text: textContent, // NEW - HTML content
                    frameNumber: parseInt(row.querySelector('.frameNumber').value, 10),
                    durationFrames: parseInt(row.querySelector('.durationFrames').value, 10)
                });
            });

            const direction = document.getElementById('direction-select')?.value || 'bottom-to-center';
            const speed = document.getElementById('speed-slider')?.value || 1;

            const overlayBgColor = document.getElementById('overlay-bg-color')?.value || '#ffffff';
            const overlayBgOpacity = (parseInt(document.getElementById('overlay-bg-opacity')?.value || '95', 10) / 100);
            const overlayWidth = parseInt(document.getElementById('overlay-width-slider')?.value || '80', 10);

            const cameraEntity = document.querySelector('[camera-movement-recorder]');
            let animationData = null;
            if (cameraEntity && cameraEntity.components['camera-movement-recorder'] && selectedRecordingIndex !== null && selectedRecordingIndex >= 0) {
                const allRecordings = cameraEntity.components['camera-movement-recorder'].allRecordings;
                if (allRecordings && allRecordings[selectedRecordingIndex]) {
                    animationData = allRecordings[selectedRecordingIndex];
                }
            }

            const requiredFiles = [];
            scene.querySelectorAll('[gltf-model]').forEach(model => {
                const src = model.getAttribute('gltf-model');
                if (src && !src.startsWith('http') && !src.startsWith('url(')) {
                    requiredFiles.push(src);
                } else if (src && src.startsWith('url(')) {
                    const match = src.match(/url\((.+)\)/);
                    if (match && match[1] && !match[1].startsWith('http')) {
                        requiredFiles.push(match[1]);
                    }
                }
            });

            scene.querySelectorAll('[gaussian-splatting]').forEach(splat => {
                const splatAttr = splat.getAttribute('gaussian-splatting');
                if (splatAttr && splatAttr.src && !splatAttr.src.startsWith('http')) {
                    requiredFiles.push(splatAttr.src);
                }
            });

            articleStructure.sections.forEach(section => {
                if (section.type === 'video') {
                    const video = videosList[section.videoIndex];
                    if (video && video.filename) {
                        requiredFiles.push(video.filename);
                    }
                }
            });

            let scriptIncludes = '<script src="https://aframe.io/releases/1.7.1/aframe.min.js"><\/script>\n <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"><\/script>';
            if (currentEffect && currentEffect !== 'none') {
                scriptIncludes += '\n <script src="post-processing.js"><\/script>';
            }
            if (hasGaussianSplats) {
                scriptIncludes += '\n <script src="gaussian-splat-viewer.js"><\/script>';
            }

            const animationDataStr = animationData ? JSON.stringify(animationData) : 'null';
            const textSlidesStr = JSON.stringify(textSlides);

            let fileRequirementsComment = '<!--\n';
            fileRequirementsComment += ' REQUIRED FILES FOR THIS SCENE TO WORK:\n';
            fileRequirementsComment += ' \n';
            fileRequirementsComment += ' Place the following files in the SAME FOLDER as this HTML file:\n';
            fileRequirementsComment += ' \n';

            if (currentEffect && currentEffect !== 'none') {
                fileRequirementsComment += ' 1. post-processing.js (required for visual effects)\n';
            }

            if (hasGaussianSplats) {
                fileRequirementsComment += ' 2. gaussian-splat-viewer.js (required for Gaussian Splat rendering)\n';
            }

            if (requiredFiles.length > 0) {
                fileRequirementsComment += ' \n';
                fileRequirementsComment += ' 3D MODEL FILES:\n';
                requiredFiles.forEach((file, index) => {
                    fileRequirementsComment += ' - ' + file + '\n';
                });
            }

            fileRequirementsComment += ' \n';
            fileRequirementsComment += ' CONTROLS:\n';
            if (animationData) {
                fileRequirementsComment += ' - Use MOUSE WHEEL to scroll through the animation\n';
                fileRequirementsComment += ' - Text will appear automatically at specified frames\n';
            } else {
                fileRequirementsComment += ' - Use WASD keys to move the camera\n';
                fileRequirementsComment += ' - Use MOUSE to look around\n';
            }
            fileRequirementsComment += '-->\n';

            // Convert overlay color to RGB for export
            const hexColor = overlayBgColor.replace('#', '');
            const r = parseInt(hexColor.substring(0, 2), 16);
            const g = parseInt(hexColor.substring(2, 4), 16);
            const b = parseInt(hexColor.substring(4, 6), 16);

            const exportedHTML = '<!DOCTYPE html>\n' +
                '<html lang="en">\n' +
                '<head>\n' +
                ' <meta charset="UTF-8" />\n' +
                ' <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n' +
                ' <title>' + projectName + '</title>\n' +
                fileRequirementsComment +
                ' ' + scriptIncludes + '\n' +
                ' \n' +
                ' <style>\n' +
                ' body {\n' +
                ' margin: 0;\n' +
                ' overflow: hidden;\n' +
                ' }\n' +
                '\n' +
                ' .text-overlay {\n' +
                ' position: fixed;\n' +
                ' left: 50%;\n' +
                ' transform: translateX(-50%);\n' +
                ' background: rgba(' + r + ', ' + g + ', ' + b + ', ' + overlayBgOpacity + ');\n' +
                ' color: #2d3748;\n' +
                ' padding: 20px 40px;\n' +
                ' border-radius: 10px;\n' +
                ' font-size: 24px;\n' +
                ' font-family: Arial, sans-serif;\n' +
                ' transition: bottom 0.5s ease, opacity 0.5s ease;\n' +
                ' opacity: 0;\n' +
                ' z-index: 10000;\n' +
                ' max-width: ' + overlayWidth + '%;\n' +
                ' text-align: center;\n' +
                ' }\n' +
                ' </style>\n' +
                '\n' +
                ' <script>\n' +
                ' /* \n' +
                ' * Scroll Viewer Component\n' +
                ' * Handles camera animation and text overlay display\n' +
                ' */\n' +
                ' \n' +
                ' // Embedded animation data\n' +
                ' const ANIMATION_DATA = ' + animationDataStr + ';\n' +
                ' const TEXT_SLIDES = ' + textSlidesStr + ';\n' +
                ' const DIRECTION = "' + direction + '";\n' +
                ' const SPEED = ' + speed + ';\n' +
                '\n' +
                ' AFRAME.registerComponent("scroll-viewer", {\n' +
                ' schema: {\n' +
                ' speed: { type: "number", default: ' + speed + ' },\n' +
                ' direction: { type: "string", default: "' + direction + '" }\n' +
                ' },\n' +
                '\n' +
                ' init: function () {\n' +
                ' this.textDisplayRange = 10;\n' +
                ' this.animationData = ANIMATION_DATA;\n' +
                ' this.textSlides = TEXT_SLIDES;\n' +
                ' this.steps = [];\n' +
                ' this.currentStepIndex = 0;\n' +
                ' this.currentIndex = 0;\n' +
                '\n' +
                ' if (this.animationData) {\n' +
                ' this.steps = Object.keys(this.animationData).filter(key => key.startsWith("step_"));\n' +
                ' this.setupScrollListener();\n' +
                ' this.el.removeAttribute("look-controls");\n' +
                ' // Set initial camera position and rotation to first frame\n' +
                ' if (this.steps.length > 0) {\n' +
                ' const firstStep = this.animationData[this.steps[0]];\n' +
                ' if (firstStep && firstStep.position && firstStep.position.length > 0) {\n' +
                ' const pos = firstStep.position[0];\n' +
                ' const rot = firstStep.rotation[0];\n' +
                ' this.el.setAttribute("position", pos[0] + " " + pos[1] + " " + pos[2]);\n' +
                ' let quaternion = new THREE.Quaternion();\n' +
                ' quaternion.setFromEuler(new THREE.Euler(\n' +
                ' THREE.MathUtils.degToRad(rot[0]),\n' +
                ' THREE.MathUtils.degToRad(rot[1]),\n' +
                ' THREE.MathUtils.degToRad(rot[2]),\n' +
                ' "YXZ"\n' +
                ' ));\n' +
                ' this.el.object3D.quaternion.copy(quaternion);\n' +
                ' }\n' +
                ' }\n' +
                ' } else {\n' +
                ' this.el.setAttribute("wasd-controls", "acceleration: 10");\n' +
                ' this.el.setAttribute("look-controls", "");\n' +
                ' }\n' +
                ' },\n' +
                '\n' +
                ' setupScrollListener: function () {\n' +
                ' window.addEventListener("wheel", (event) => {\n' +
                ' if (event.deltaY > 0) {\n' +
                ' this.nextFrame();\n' +
                ' } else {\n' +
                ' this.previousFrame();\n' +
                ' }\n' +
                ' });\n' +
                ' },\n' +
                '\n' +
                ' nextFrame: function () {\n' +
                ' if (!this.animationData || this.steps.length === 0) return;\n' +
                ' if (this.currentStepIndex >= this.steps.length - 1 && this.currentIndex >= this.animationData[this.steps[this.currentStepIndex]].position.length - 1) return;\n' +
                ' let stepKey = this.steps[this.currentStepIndex];\n' +
                ' let stepData = this.animationData[stepKey];\n' +
                ' if (!stepData || !stepData.position) return;\n' +
                ' this.currentIndex += this.data.speed;\n' +
                ' if (this.currentIndex >= stepData.position.length) {\n' +
                ' this.currentStepIndex++;\n' +
                ' this.currentIndex = 0;\n' +
                ' if (this.currentStepIndex >= this.steps.length) {\n' +
                ' this.currentStepIndex = this.steps.length - 1;\n' +
                ' this.currentIndex = stepData.position.length - 1;\n' +
                ' return;\n' +
                ' }\n' +
                ' stepKey = this.steps[this.currentStepIndex];\n' +
                ' stepData = this.animationData[stepKey];\n' +
                ' }\n' +
                ' this.updateCameraPosition(stepData);\n' +
                ' this.updateTextOverlay();\n' +
                ' },\n' +
                '\n' +
                ' previousFrame: function () {\n' +
                ' if (!this.animationData || this.steps.length === 0) return;\n' +
                ' if (this.currentStepIndex <= 0 && this.currentIndex <= 0) return;\n' +
                ' let stepKey = this.steps[this.currentStepIndex];\n' +
                ' let stepData = this.animationData[stepKey];\n' +
                ' if (!stepData || !stepData.position) return;\n' +
                ' this.currentIndex -= this.data.speed;\n' +
                ' if (this.currentIndex < 0) {\n' +
                ' this.currentStepIndex--;\n' +
                ' this.currentIndex = 0;\n' +
                ' if (this.currentStepIndex < 0) {\n' +
                ' this.currentStepIndex = 0;\n' +
                ' this.currentIndex = 0;\n' +
                ' return;\n' +
                ' }\n' +
                ' stepKey = this.steps[this.currentStepIndex];\n' +
                ' stepData = this.animationData[stepKey];\n' +
                ' this.currentIndex = stepData.position.length - 1;\n' +
                ' }\n' +
                ' this.updateCameraPosition(stepData);\n' +
                ' this.updateTextOverlay();\n' +
                ' },\n' +
                '\n' +
                ' updateCameraPosition: function (stepData) {\n' +
                ' let pos = stepData.position[this.currentIndex];\n' +
                ' let rot = stepData.rotation[this.currentIndex];\n' +
                ' this.el.setAttribute("position", pos[0] + " " + pos[1] + " " + pos[2]);\n' +
                ' let quaternion = new THREE.Quaternion();\n' +
                ' quaternion.setFromEuler(new THREE.Euler(\n' +
                ' THREE.MathUtils.degToRad(rot[0]),\n' +
                ' THREE.MathUtils.degToRad(rot[1]),\n' +
                ' THREE.MathUtils.degToRad(rot[2]),\n' +
                ' "YXZ"\n' +
                ' ));\n' +
                ' this.el.object3D.quaternion.slerp(quaternion, 0.1);\n' +
                ' },\n' +
                '\n' +
                ' updateTextOverlay: function () {\n' +
                ' const currentFrame = this.currentIndex + 1;\n' +
                ' let foundText = false;\n' +
                ' this.textSlides.forEach((slide) => {\n' +
                ' const frameNumber = slide.frameNumber;\n' +
                ' const durationFrames = slide.durationFrames;\n' +
                ' const text = slide.text;\n' +
                ' const startFrame = frameNumber - this.textDisplayRange;\n' +
                ' const endFrame = frameNumber + durationFrames + this.textDisplayRange;\n' +
                ' if (currentFrame >= startFrame && currentFrame <= endFrame) {\n' +
                ' const progress = this.calculateProgress(currentFrame, frameNumber, durationFrames);\n' +
                ' this.showTextOverlay(text, progress);\n' +
                ' foundText = true;\n' +
                ' }\n' +
                ' });\n' +
                ' if (!foundText) {\n' +
                ' this.hideTextOverlay();\n' +
                ' }\n' +
                ' },\n' +
                '\n' +
                ' calculateProgress: function (currentFrame, targetFrame, durationFrames) {\n' +
                ' const fadeInDuration = this.textDisplayRange;\n' +
                ' const fadeOutDuration = this.textDisplayRange;\n' +
                ' const fadeOutStart = targetFrame + durationFrames;\n' +
                ' if (currentFrame < targetFrame) {\n' +
                ' return 0.5 * (currentFrame - (targetFrame - fadeInDuration)) / fadeInDuration;\n' +
                ' } else if (currentFrame >= targetFrame && currentFrame < fadeOutStart) {\n' +
                ' return 1;\n' +
                ' } else if (currentFrame >= fadeOutStart && currentFrame <= fadeOutStart + fadeOutDuration) {\n' +
                ' return 1 + 0.5 * ((currentFrame - fadeOutStart) / fadeOutDuration);\n' +
                ' } else {\n' +
                ' return 0;\n' +
                ' }\n' +
                ' },\n' +
                '\n' +
                ' showTextOverlay: function (text, progress) {\n' +
                ' let textOverlay = document.querySelector(".text-overlay");\n' +
                ' if (!textOverlay) {\n' +
                ' textOverlay = document.createElement("div");\n' +
                ' textOverlay.className = "text-overlay";\n' +
                ' document.body.appendChild(textOverlay);\n' +
                ' }\n' +
                ' textOverlay.innerHTML = text;\n' +
                ' let opacity, position;\n' +
                ' if (progress < 0.5) {\n' +
                ' opacity = progress * 2;\n' +
                ' position = this.calculateStartPosition(progress * 2);\n' +
                ' } else if (progress >= 0.5 && progress <= 1) {\n' +
                ' opacity = 1;\n' +
                ' position = { left: "50%", top: "50%", transform: "translate(-50%, -50%)" };\n' +
                ' } else if (progress > 1 && progress <= 1.5) {\n' +
                ' opacity = 1 - ((progress - 1) * 2);\n' +
                ' position = this.calculateEndPosition((progress - 1) * 2);\n' +
                ' } else {\n' +
                ' opacity = 0;\n' +
                ' position = this.calculateEndPosition(1);\n' +
                ' }\n' +
                ' textOverlay.style.opacity = opacity;\n' +
                ' textOverlay.style.left = position.left;\n' +
                ' textOverlay.style.top = position.top;\n' +
                ' textOverlay.style.transform = position.transform;\n' +
                ' },\n' +
                '\n' +
                ' calculateStartPosition: function (progress) {\n' +
                ' const direction = this.data.direction;\n' +
                ' switch (direction) {\n' +
                ' case "bottom-to-center":\n' +
                ' return { left: "50%", top: (100 - (progress * 50)) + "%", transform: "translate(-50%, -50%)" };\n' +
                ' case "left-to-center":\n' +
                ' return { left: (progress * 50) + "%", top: "50%", transform: "translate(-50%, -50%)" };\n' +
                ' case "right-to-center":\n' +
                ' return { left: (100 - (progress * 50)) + "%", top: "50%", transform: "translate(-50%, -50%)" };\n' +
                ' case "top-to-center":\n' +
                ' return { left: "50%", top: (progress * 50) + "%", transform: "translate(-50%, -50%)" };\n' +
                ' default:\n' +
                ' return { left: "50%", top: "50%", transform: "translate(-50%, -50%)" };\n' +
                ' }\n' +
                ' },\n' +
                '\n' +
                ' calculateEndPosition: function (progress) {\n' +
                ' const direction = this.data.direction;\n' +
                ' switch (direction) {\n' +
                ' case "bottom-to-center":\n' +
                ' return { left: "50%", top: (50 - (progress * 50)) + "%", transform: "translate(-50%, -50%)" };\n' +
                ' case "left-to-center":\n' +
                ' return { left: (50 + (progress * 50)) + "%", top: "50%", transform: "translate(-50%, -50%)" };\n' +
                ' case "right-to-center":\n' +
                ' return { left: (50 - (progress * 50)) + "%", top: "50%", transform: "translate(-50%, -50%)" };\n' +
                ' case "top-to-center":\n' +
                ' return { left: "50%", top: (50 + (progress * 50)) + "%", transform: "translate(-50%, -50%)" };\n' +
                ' default:\n' +
                ' return { left: "50%", top: "50%", transform: "translate(-50%, -50%)" };\n' +
                ' }\n' +
                ' },\n' +
                '\n' +
                ' hideTextOverlay: function () {\n' +
                ' const textOverlay = document.querySelector(".text-overlay");\n' +
                ' if (textOverlay) {\n' +
                ' textOverlay.style.opacity = 0;\n' +
                ' textOverlay.style.left = "50%";\n' +
                ' textOverlay.style.top = "100%";\n' +
                ' textOverlay.style.transform = "translate(-50%, -50%)";\n' +
                ' }\n' +
                ' }\n' +
                ' });\n' +
                ' <\/script>\n' +
                '</head>\n' +
                '<body>\n' +
                ' <a-scene' + (currentEffect && currentEffect !== 'none' ? ' post-processing="effect: ' + currentEffect + '"' : '') + '>\n' +
                ' <a-entity scroll-viewer camera position="0 1.6 0"></a-entity>\n' +
                ' <a-sky color="' + skyColor + '"></a-sky>\n' +
                ' ' + sceneContent + '\n' +
                ' </a-scene>\n' +
                '</body>\n' +
                '</html>';

            const blob = new Blob([exportedHTML], { type: 'text/html' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            // Sanitize filename - remove special characters, replace spaces with hyphens
            const sanitizedFilename = exportName.toLowerCase()
                .replace(/[^a-z0-9-_]/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '') || 'my-3d-scene';
            link.download = sanitizedFilename + '.html';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log('Scene exported successfully!');
            console.log('- Animation data:', animationData ? 'Included' : 'Not included');
            console.log('- Text slides:', textSlides.length);
            console.log('- Post-processing effect:', currentEffect);
            console.log('- Gaussian splats:', hasGaussianSplats ? 'Yes' : 'No');
            console.log('- Required files:', requiredFiles);
        }


        // Modal script
        let pendingRecordingCallback = null;

        function showRecordingModal(defaultName, callback) {
            const modal = document.getElementById('recording-name-modal');
            const input = document.getElementById('recording-name-input');
            input.value = defaultName;
            modal.classList.add('active');
            input.focus();
            input.select();
            pendingRecordingCallback = callback;

            // Allow Enter key to save
            input.onkeypress = function (e) {
                if (e.key === 'Enter') {
                    saveRecordingWithName();
                }
            };
        }

        function closeRecordingModal() {
            const modal = document.getElementById('recording-name-modal');
            modal.classList.remove('active');
            pendingRecordingCallback = null;
        }

        function saveRecordingWithName() {
            const input = document.getElementById('recording-name-input');
            const name = input.value.trim();
            if (name && pendingRecordingCallback) {
                pendingRecordingCallback(name);
            }
            closeRecordingModal();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const colorIcon = document.getElementById('overlay-bg-color-icon');
            const colorInput = document.getElementById('overlay-bg-color');


            if (!colorIcon || !colorInput) return;

            // Click icon → open native color picker
            colorIcon.addEventListener('click', () => {
                colorInput.showPicker();
            });

            // Update preview square + real value when color changes
            colorInput.addEventListener('input', (e) => {
                const newColor = e.target.value;


                // Optional: also update the overlay live (if you want instant preview)
                const overlay = document.querySelector('.text-overlay');
                if (overlay) {
                    overlay.style.background = `rgba(${parseInt(newColor.slice(1, 3), 16)}, ${parseInt(newColor.slice(3, 5), 16)}, ${parseInt(newColor.slice(5, 7), 16)}, ${document.getElementById('overlay-bg-opacity').value / 100})`;
                }
            });


        });



        // ═══════════════════════════════════════════════════════════════
        // ARTICLE STRUCTURE MANAGEMENT
        // ═══════════════════════════════════════════════════════════════

        let articleStructure = {
            sections: [],
            currentEditIndex: -1
        };

        let articleSectionQuill = null;
        let newSlideQuill = null;

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Quill editor for article sections
            articleSectionQuill = new Quill('#article-section-editor', {
                theme: 'snow',
                placeholder: 'Write your article content here...',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline'],
                        [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                        [{ 'color': [] }, { 'background': [] }],
                        ['link', 'image'],
                        ['clean']
                    ]
                }
            });
            initializeAnnotations();
            // Button listeners
            document.getElementById('add-article-section-btn')?.addEventListener('click', () => {
                openArticleSectionModal();
            });

            document.getElementById('add-3d-section-btn')?.addEventListener('click', () => {
                open3DSectionModal();
            });

            document.getElementById('add-hotspot-section-btn')?.addEventListener('click', () => {
                openHotspotSectionModal();
            });

            document.getElementById('export-article-btn')?.addEventListener('click', () => {
                openExportArticleModal();
            });

            // Height slider
            const heightSlider = document.getElementById('article-section-height');
            const heightValue = document.getElementById('article-section-height-value');
            if (heightSlider && heightValue) {
                heightSlider.addEventListener('input', (e) => {
                    heightValue.textContent = e.target.value;
                });
            }

            // Duration slider
            const durationSlider = document.getElementById('3d-section-duration');
            const durationValue = document.getElementById('3d-section-duration-value');
            if (durationSlider && durationValue) {
                durationSlider.addEventListener('input', (e) => {
                    durationValue.textContent = e.target.value;
                });
            }

            // Annotation sliders
            const fontSizeSlider = document.getElementById('annotation-font-size');
            const fontSizeValue = document.getElementById('annotation-font-size-value');
            if (fontSizeSlider && fontSizeValue) {
                fontSizeSlider.addEventListener('input', (e) => {
                    fontSizeValue.textContent = e.target.value;
                });
            }

            const maxWidthSlider = document.getElementById('annotation-max-width');
            const maxWidthValue = document.getElementById('annotation-max-width-value');
            if (maxWidthSlider && maxWidthValue) {
                maxWidthSlider.addEventListener('input', (e) => {
                    maxWidthValue.textContent = e.target.value;
                });
            }

            // Audio section height slider
            const audioHeightSlider = document.getElementById('audio-section-height');
            const audioHeightValue = document.getElementById('audio-section-height-value');
            if (audioHeightSlider && audioHeightValue) {
                audioHeightSlider.addEventListener('input', (e) => {
                    audioHeightValue.textContent = e.target.value;
                });
            }

            // Video section duration slider
            const videoSectionDurationSlider = document.getElementById('video-section-duration');
            const videoSectionDurationValue = document.getElementById('video-section-duration-value');
            if (videoSectionDurationSlider && videoSectionDurationValue) {
                videoSectionDurationSlider.addEventListener('input', (e) => {
                    videoSectionDurationValue.textContent = e.target.value;
                });
            }

            // Hotspot section height slider
            const hotspotHeightSlider = document.getElementById('hotspot-section-height');
            const hotspotHeightValue = document.getElementById('hotspot-section-height-value');
            if (hotspotHeightSlider && hotspotHeightValue) {
                hotspotHeightSlider.addEventListener('input', (e) => {
                    hotspotHeightValue.textContent = e.target.value;
                });
            }
            // Text overlay checkbox
            document.getElementById('3d-section-has-text')?.addEventListener('change', (e) => {
                document.getElementById('3d-section-text-slides').style.display =
                    e.target.checked ? 'block' : 'none';
            });
        });

        function openArticleSectionModal(index = -1) {
            articleStructure.currentEditIndex = index;
            const modal = document.getElementById('article-section-modal');

            if (index >= 0) {
                const section = articleStructure.sections[index];
                document.getElementById('article-section-title').value = section.title;
                articleSectionQuill.root.innerHTML = section.content;
                document.getElementById('article-section-bg').value = section.bgColor;
                document.getElementById('article-section-height').value = section.minHeight;
                document.getElementById('article-section-height-value').textContent = section.minHeight;
            } else {
                document.getElementById('article-section-title').value = '';
                articleSectionQuill.setText('');
                document.getElementById('article-section-bg').value = '#ffffff';
                document.getElementById('article-section-height').value = 100;
                document.getElementById('article-section-height-value').textContent = '100';
            }

            modal.classList.add('active');
        }

        function closeArticleSectionModal() {
            document.getElementById('article-section-modal').classList.remove('active');
            articleStructure.currentEditIndex = -1;
        }

        function saveArticleSection() {
            const section = {
                type: 'article',
                title: document.getElementById('article-section-title').value,
                content: articleSectionQuill.root.innerHTML,
                bgColor: document.getElementById('article-section-bg').value,
                minHeight: parseInt(document.getElementById('article-section-height').value)
            };

            if (articleStructure.currentEditIndex >= 0) {
                articleStructure.sections[articleStructure.currentEditIndex] = section;
            } else {
                articleStructure.sections.push(section);
            }

            updateSectionsList();
            closeArticleSectionModal();
        }

        function open3DSectionModal(index = -1) {
            articleStructure.currentEditIndex = index;
            const modal = document.getElementById('3d-section-modal');
            const select = document.getElementById('3d-section-recording');

            // Populate recordings
            const cameraEntity = document.querySelector('[camera-movement-recorder]');
            if (cameraEntity?.components['camera-movement-recorder']) {
                const recordings = cameraEntity.components['camera-movement-recorder'].allRecordings;
                select.innerHTML = '<option value="">Select a camera path...</option>';
                recordings.forEach((rec, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = rec.name;
                    select.appendChild(option);
                });
            }

            if (index >= 0) {
                const section = articleStructure.sections[index];
                document.getElementById('3d-section-name').value = section.name;
                select.value = section.recordingIndex;
                document.getElementById('3d-section-duration').value = section.scrollDuration;
                document.getElementById('3d-section-duration-value').textContent = section.scrollDuration;
                document.getElementById('3d-section-has-text').checked = section.hasTextSlides;

                // UPDATE THIS PART to show slide count
                const textSlidesDiv = document.getElementById('3d-section-text-slides');
                if (section.hasTextSlides && section.textSlides && section.textSlides.length > 0) {
                    const validSlides = section.textSlides.filter(s => s.frameNumber > 0 && s.durationFrames > 0);
                    const invalidSlides = section.textSlides.length - validSlides.length;

                    textSlidesDiv.innerHTML = `
                <h4>Text Slides</h4>
                <p style="font-size: 12px; color: #718096;">
                    ${validSlides.length} valid slide(s) saved with this section
                    ${invalidSlides > 0 ? `<br><span style="color: #f56565;">${invalidSlides} invalid slide(s) (missing frame/duration)</span>` : ''}
                </p>
            `;
                    textSlidesDiv.style.display = 'block';
                } else if (section.hasTextSlides) {
                    textSlidesDiv.innerHTML = `
                <h4>Text Slides</h4>
                <p style="font-size: 12px; color: #718096;">
                    Configure slides in Scrollytelling panel, then save this section again
                </p>
            `;
                    textSlidesDiv.style.display = 'block';
                } else {
                    textSlidesDiv.style.display = 'none';
                }
            } else {
                document.getElementById('3d-section-name').value = '';
                select.value = '';
                document.getElementById('3d-section-duration').value = 300;
                document.getElementById('3d-section-duration-value').textContent = '300';
                document.getElementById('3d-section-has-text').checked = false;
                document.getElementById('3d-section-text-slides').style.display = 'none';
            }

            modal.classList.add('active');
        }

        function close3DSectionModal() {
            document.getElementById('3d-section-modal').classList.remove('active');
            articleStructure.currentEditIndex = -1;
        }

        function save3DSection() {
            const scrollEntity = document.querySelector('[scroll-animator]');
            const scrollComponent = scrollEntity?.components['scroll-animator'];

            // Get text slides for the selected recording
            const selectedRecordingIndex = parseInt(document.getElementById('3d-section-recording').value);
            let textSlides = [];

            if (document.getElementById('3d-section-has-text').checked && scrollComponent) {
                // Save current slides before capturing
                scrollComponent.autoSaveCurrentSlides();
                const rawSlides = scrollComponent.recordingTextSlides[selectedRecordingIndex] || [];

                // Filter out invalid slides (frameNumber and durationFrames must be > 0)
                textSlides = rawSlides.filter(slide => {
                    return slide.frameNumber > 0 && slide.durationFrames > 0;
                });

                // Warn if some slides were invalid
                if (rawSlides.length > textSlides.length) {
                    showNotification(`Warning: ${rawSlides.length - textSlides.length} slide(s) were not saved because they have invalid frame numbers or durations. Please make sure all slides have Frame Number > 0 and Duration > 0.`, "warning", 5000);
                }
            }

            const section = {
                type: '3d',
                name: document.getElementById('3d-section-name').value,
                recordingIndex: selectedRecordingIndex,
                scrollDuration: parseInt(document.getElementById('3d-section-duration').value),
                hasTextSlides: document.getElementById('3d-section-has-text').checked,
                textSlides: textSlides
            };

            if (articleStructure.currentEditIndex >= 0) {
                articleStructure.sections[articleStructure.currentEditIndex] = section;
            } else {
                articleStructure.sections.push(section);
            }

            updateSectionsList();
            close3DSectionModal();
        }

        function openHotspotSectionModal(index = -1) {
            articleStructure.currentEditIndex = index;
            const modal = document.getElementById('hotspot-section-modal');
            const select = document.getElementById('hotspot-section-select');

            // Populate hotspots
            select.innerHTML = '<option value="">Select a hotspot...</option>';
            hotspotsList.forEach((hotspot, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = hotspot.name;
                select.appendChild(option);
            });

            if (index >= 0) {
                const section = articleStructure.sections[index];
                document.getElementById('hotspot-section-name').value = section.name;
                select.value = section.hotspotIndex;
                document.getElementById('hotspot-section-bg').value = section.bgColor;
                document.getElementById('hotspot-section-height').value = section.minHeight;
                document.getElementById('hotspot-section-height-value').textContent = section.minHeight;
            } else {
                document.getElementById('hotspot-section-name').value = '';
                select.value = '';
                document.getElementById('hotspot-section-bg').value = '#ffffff';
                document.getElementById('hotspot-section-height').value = 100;
                document.getElementById('hotspot-section-height-value').textContent = '100';
            }

            modal.classList.add('active');
        }

        function closeHotspotSectionModal() {
            document.getElementById('hotspot-section-modal').classList.remove('active');
            articleStructure.currentEditIndex = -1;
        }

        function saveHotspotSection() {
            const hotspotIndex = parseInt(document.getElementById('hotspot-section-select').value);

            if (hotspotIndex === '' || isNaN(hotspotIndex)) {
                showNotification('Please select a hotspot', 'warning');
                return;
            }

            const section = {
                type: 'hotspot',
                name: document.getElementById('hotspot-section-name').value,
                hotspotIndex: hotspotIndex,
                bgColor: document.getElementById('hotspot-section-bg').value,
                minHeight: parseInt(document.getElementById('hotspot-section-height').value)
            };

            if (articleStructure.currentEditIndex >= 0) {
                articleStructure.sections[articleStructure.currentEditIndex] = section;
            } else {
                articleStructure.sections.push(section);
            }

            updateSectionsList();
            closeHotspotSectionModal();
        }

        function updateSectionsList() {
            const container = document.getElementById('sections-list');

            if (articleStructure.sections.length === 0) {
                container.innerHTML = '<p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">No sections yet. Add an article or 3D section to begin.</p>';
                return;
            }

            let html = '';
            articleStructure.sections.forEach((section, index) => {
                let icon, title, subtitle;

                if (section.type === 'article') {
                    icon = '📄';
                    title = section.title;
                    subtitle = `${section.minHeight}vh height`;
                } else if (section.type === '3d') {
                    icon = '🎬';
                    title = section.name;
                    subtitle = `Camera path ${section.recordingIndex + 1}, ${section.scrollDuration}vh`;
                } else if (section.type === 'hotspot') {
                    icon = '📍';
                    title = section.name;
                    const hotspot = hotspotsList[section.hotspotIndex];
                    subtitle = `${hotspot ? hotspot.name : 'Unknown'}, ${section.minHeight}vh`;
                } else if (section.type === 'video') {
                    icon = '🎥';
                    title = section.name;
                    const video = videosList[section.videoIndex];
                    subtitle = `${video ? video.title : 'Unknown'}, ${section.scrollDuration}vh`;
                } else if (section.type === 'audio') {
                    icon = '🔊';
                    title = section.title;
                    subtitle = `${section.voice}, ${section.minHeight}vh`;
                }

                html += `
            <div class="project-list-item" style="cursor: default;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div class="project-name">${icon} ${title || 'Untitled'}</div>
                        <div class="project-date">${subtitle}</div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="editSection(${index})" style="padding: 6px 12px; margin: 0; background: #4299e1;">Edit</button>
                        <button onclick="deleteSection(${index})" style="padding: 6px 12px; margin: 0; background: #f56565;">Delete</button>
                        ${index > 0 ? `<button onclick="moveSection(${index}, -1)" style="padding: 6px 12px; margin: 0; background: #718096;">↑</button>` : ''}
                        ${index < articleStructure.sections.length - 1 ? `<button onclick="moveSection(${index}, 1)" style="padding: 6px 12px; margin: 0; background: #718096;">↓</button>` : ''}
                    </div>
                </div>
            </div>
        `;
            });

            container.innerHTML = html;
        }

        function editSection(index) {
            const section = articleStructure.sections[index];
            if (section.type === 'article') {
                openArticleSectionModal(index);
            } else if (section.type === '3d') {
                open3DSectionModal(index);
            } else if (section.type === 'hotspot') {
                openHotspotSectionModal(index);
            } else if (section.type === 'video') {
                openVideoSectionModal(index);
            } else if (section.type === 'audio') {
                openAudioSectionModal(index);
            }
        }

        function deleteSection(index) {
            if (confirm('Delete this section?')) {
                articleStructure.sections.splice(index, 1);
                updateSectionsList();
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // AUDIO SECTION MANAGEMENT
        // ═══════════════════════════════════════════════════════════════

        let availableVoices = [];

        async function loadVoicesForAudioPanel() {
            if (availableVoices.length === 0) {
                try {
                    const response = await fetch('/api/voices');

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const text = await response.text();

                    if (!text || text.trim() === '') {
                        throw new Error('Empty response from server');
                    }

                    const voices = JSON.parse(text);

                    if (!Array.isArray(voices) || voices.length === 0) {
                        throw new Error('Invalid voices data');
                    }

                    availableVoices = voices;

                    const voiceSelect = document.getElementById('audio-voice-select');
                    voiceSelect.innerHTML = voices.map(v =>
                        `<option value="${v}">${v}</option>`
                    ).join('');

                } catch (err) {
                    console.error('Failed to load voices:', err);

                    availableVoices = ["af_heart", "af_bella", "af_sarah", "am_adam", "am_michael"];

                    const voiceSelect = document.getElementById('audio-voice-select');
                    voiceSelect.innerHTML = availableVoices.map(v =>
                        `<option value="${v}">${v}</option>`
                    ).join('');

                    showNotification('Using default voices (server not ready)', 'warning', 2000);
                }
            }
        }


        function showAudioPreviewInPanel(audioUrl, text) {
            const container = document.getElementById('audio-preview-container');
            const audio = document.getElementById('audio-preview');
            const info = document.getElementById('audio-info');

            audio.src = audioUrl;
            info.textContent = `Generated from: "${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"`;
            container.style.display = 'block';
        }

        function saveGeneratedAudio() {
            if (!currentGeneratedAudio) {
                showNotification('Please generate audio first', 'warning');
                return;
            }

            const title = document.getElementById('audio-title-input').value.trim();

            if (!title) {
                showNotification('Please enter an audio title', 'warning');
                return;
            }

            const audioId = 'audio-' + Date.now();

            audiosList.push({
                id: audioId,
                title: title,
                ...currentGeneratedAudio
            });

            updateAudioFilesList();

            // Clear form
            document.getElementById('audio-title-input').value = '';
            document.getElementById('audio-text-input').value = '';
            document.getElementById('audio-preview-container').style.display = 'none';
            currentGeneratedAudio = null;

            showNotification(`Audio "${title}" saved successfully`, 'success');
        }

        function updateAudioFilesList() {
            const container = document.getElementById('audio-files-list');

            if (audiosList.length === 0) {
                container.innerHTML = '<p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">No audio files yet. Generate audio above to create one.</p>';
                return;
            }

            let html = '';
            audiosList.forEach((audio) => {
                const isSelected = selectedAudioId === audio.id;
                html += `
            <div class="project-list-item ${isSelected ? 'selected' : ''}" 
                onclick="selectAudio('${audio.id}')"
                style="cursor: pointer;">
                <div class="project-name">${audio.title}</div>
                <div class="project-date">${audio.voice}, ${audio.dtype}</div>
            </div>
        `;
            });

            container.innerHTML = html;
        }

        function selectAudio(audioId) {
            selectedAudioId = audioId;
            updateAudioFilesList();
        }

        function deleteSelectedAudio() {
            if (!selectedAudioId) {
                showNotification('Please select an audio file to delete', 'warning');
                return;
            }

            const audio = audiosList.find(a => a.id === selectedAudioId);
            if (!audio) return;

            if (!confirm(`Delete audio "${audio.title}"?`)) {
                return;
            }

            audiosList = audiosList.filter(a => a.id !== selectedAudioId);
            selectedAudioId = null;

            updateAudioFilesList();
            showNotification('Audio deleted', 'success');
        }

        function openAudioSectionModal(index = -1) {
            articleStructure.currentEditIndex = index;
            const modal = document.getElementById('audio-section-modal');
            const select = document.getElementById('audio-section-select');

            // Populate audio files
            select.innerHTML = '<option value="">Select an audio file...</option>';
            audiosList.forEach((audio, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = audio.title;
                select.appendChild(option);
            });

            if (index >= 0) {
                const section = articleStructure.sections[index];
                document.getElementById('audio-section-title').value = section.title;
                select.value = section.audioIndex;
                document.getElementById('audio-section-bg').value = section.bgColor;
                document.getElementById('audio-section-height').value = section.minHeight;
                document.getElementById('audio-section-height-value').textContent = section.minHeight;
            } else {
                document.getElementById('audio-section-title').value = '';
                select.value = '';
                document.getElementById('audio-section-bg').value = '#f7fafc';
                document.getElementById('audio-section-height').value = 80;
                document.getElementById('audio-section-height-value').textContent = '80';
            }

            modal.classList.add('active');
        }

        function closeAudioSectionModal() {
            document.getElementById('audio-section-modal').classList.remove('active');
            articleStructure.currentEditIndex = -1;
            currentAudioFile = null;
        }


        function showAudioPreview(audioUrl, text) {
            const container = document.getElementById('audio-preview-container');
            const audio = document.getElementById('audio-preview');
            const info = document.getElementById('audio-info');

            audio.src = audioUrl;
            info.textContent = `Generated from: "${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"`;
            container.style.display = 'block';
        }

        function saveAudioSection() {
            const title = document.getElementById('audio-section-title').value.trim();
            const audioIndex = parseInt(document.getElementById('audio-section-select').value);

            if (!title) {
                showNotification('Please enter a section title', 'warning');
                return;
            }

            if (audioIndex === '' || isNaN(audioIndex)) {
                showNotification('Please select an audio file', 'warning');
                return;
            }

            const audio = audiosList[audioIndex];

            const section = {
                type: 'audio',
                title: title,
                audioIndex: audioIndex,
                text: audio.text,
                audioUrl: audio.audioUrl,
                voice: audio.voice,
                dtype: audio.dtype,
                bgColor: document.getElementById('audio-section-bg').value,
                minHeight: parseInt(document.getElementById('audio-section-height').value)
            };

            if (articleStructure.currentEditIndex >= 0) {
                articleStructure.sections[articleStructure.currentEditIndex] = section;
            } else {
                articleStructure.sections.push(section);
            }

            updateSectionsList();
            closeAudioSectionModal();
            showNotification('Audio section added', 'success');
        }
        function moveSection(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= articleStructure.sections.length) return;

            const temp = articleStructure.sections[index];
            articleStructure.sections[index] = articleStructure.sections[newIndex];
            articleStructure.sections[newIndex] = temp;

            updateSectionsList();
        }

        function exportCompleteArticleWithName(exportName) {
            const sanitizedFilename = exportName.toLowerCase()
                .replace(/[^a-z0-9-_]/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '') || 'my-article';

            // Get overlay style settings
            const overlayBgColor = document.getElementById('overlay-bg-color')?.value || '#ffffff';
            const overlayBgOpacity = (parseInt(document.getElementById('overlay-bg-opacity')?.value || '95', 10) / 100);
            const overlayWidth = parseInt(document.getElementById('overlay-width-slider')?.value || '80', 10);

            // Convert overlay color to RGB for export
            const hexColor = overlayBgColor.replace('#', '');
            const r = parseInt(hexColor.substring(0, 2), 16);
            const g = parseInt(hexColor.substring(2, 4), 16);
            const b = parseInt(hexColor.substring(4, 6), 16);

            // Get scene data
            const scene = document.querySelector('a-scene');
            scene.flushToDOM(true);
            const sceneContent = scene.innerHTML;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = sceneContent;
            const cameraEntities = tempDiv.querySelectorAll('[camera-movement-recorder], [camera-movement-animator], [scroll-animator], [wasd-controls], [look-controls], [tooltip-component]');
            cameraEntities.forEach(el => el.remove());
            const canvases = tempDiv.querySelectorAll('canvas, .a-loader-title, [aframe-injected], .myCam');
            canvases.forEach(el => el.remove());
            const filteredSceneContent = tempDiv.innerHTML;
            const postProcessing = scene.getAttribute('post-processing');
            const currentEffect = postProcessing ? postProcessing.effect : 'none';
            const sky = scene.querySelector('a-sky');
            const skyColor = sky ? sky.getAttribute('color') : '#000000';
            const hasGaussianSplats = scene.querySelectorAll('[gaussian-splatting]').length > 0;

            // Get required files
            const requiredFiles = [];
            scene.querySelectorAll('[gltf-model]').forEach(model => {
                const src = model.getAttribute('gltf-model');
                if (src && !src.startsWith('http') && !src.startsWith('url(')) {
                    requiredFiles.push(src);
                } else if (src && src.startsWith('url(')) {
                    const match = src.match(/url\((.+)\)/);
                    if (match && match[1] && !match[1].startsWith('http')) {
                        requiredFiles.push(match[1]);
                    }
                }
            });

            scene.querySelectorAll('[gaussian-splatting]').forEach(splat => {
                const splatAttr = splat.getAttribute('gaussian-splatting');
                if (splatAttr && splatAttr.src && !splatAttr.src.startsWith('http')) {
                    requiredFiles.push(splatAttr.src);
                }
            });

            // Build script includes
            let scriptIncludes = '<script src="https://aframe.io/releases/1.7.1/aframe.min.js"><\/script>\n    <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"><\/script>';
            if (currentEffect && currentEffect !== 'none') {
                scriptIncludes += '\n    <script src="post-processing.js"><\/script>';
            }
            if (hasGaussianSplats) {
                scriptIncludes += '\n    <script src="gaussian-splat-viewer.js"><\/script>';
            }

            // Build file requirements comment
            let fileRequirementsComment = '<!--\n';
            fileRequirementsComment += '  REQUIRED FILES FOR THIS ARTICLE TO WORK:\n';
            fileRequirementsComment += '  \n';
            fileRequirementsComment += '  Place the following files in the SAME FOLDER as this HTML file:\n';
            fileRequirementsComment += '  \n';
            if (currentEffect && currentEffect !== 'none') {
                fileRequirementsComment += '  1. post-processing.js (required for visual effects)\n';
            }
            if (hasGaussianSplats) {
                fileRequirementsComment += '  2. gaussian-splat-viewer.js (required for Gaussian Splat rendering)\n';
            }
            if (requiredFiles.length > 0) {
                fileRequirementsComment += '  \n';
                fileRequirementsComment += '  3D MODEL FILES:\n';
                requiredFiles.forEach((file) => {
                    fileRequirementsComment += '  - ' + file + '\n';
                });
            }

            fileRequirementsComment += '  \n';
            fileRequirementsComment += '  VIDEO FILES:\n';
            articleStructure.sections.forEach(section => {
                if (section.type === 'video') {
                    const video = videosList[section.videoIndex];
                    if (video && video.filename) {
                        fileRequirementsComment += '  - ' + video.filename + '\n';
                    }
                }
            });
            fileRequirementsComment += '  \n';
            fileRequirementsComment += '  CONTROLS:\n';
            fileRequirementsComment += '  - Scroll naturally to read and navigate\n';
            fileRequirementsComment += '  - 3D sections animate automatically as you scroll\n';
            fileRequirementsComment += '  - Video sections play frame-by-frame as you scroll\n';
            fileRequirementsComment += '-->\n';

            // Generate HTML sections
            function generateHTMLSections(currentEffect, skyColor, sceneContent) {
                let html = '';
                let sceneCounter = 0;
                let videoCounter = 0;

                articleStructure.sections.forEach((section, index) => {
                    if (section.type === 'article') {
                        html += `
    <!-- Article Section ${index + 1} -->
    <section class="article-section" style="min-height: ${section.minHeight}vh; background: ${section.bgColor};">
        <div class="article-content">
            <h2>${section.title}</h2>
            ${section.content}
        </div>
    </section>
`;
                    } else if (section.type === '3d') {
                        const sectionId = `scene-${sceneCounter}`;
                        html += `
    <!-- 3D Section ${index + 1} - Just a spacer, scene is shared above -->
    <div class="scene-spacer" data-section-id="${sectionId}" style="height: ${section.scrollDuration}vh;"></div>
`;
                        sceneCounter++;
                    } else if (section.type === 'hotspot') {
                        const hotspot = hotspotsList[section.hotspotIndex];
                        if (hotspot) {
                            const hotspotSectionId = `hotspot-section-${index}`;
                            html += `
            <!-- Hotspot Section ${index + 1} -->
            <section class="article-section hotspot-section" id="${hotspotSectionId}" style="min-height: ${section.minHeight}vh; background: ${section.bgColor};">
                <div class="article-content">
                    <div class="hotspot-container" style="position: relative; max-width: 100%; margin: 0 auto;">
                        <img src="${hotspot.image}" style="width: 100%; height: auto; display: block;" alt="${section.name}">
                        ${hotspot.markers.map(marker => {
                                const xPercent = (marker.x / hotspot.imageWidth) * 100;
                                const yPercent = (marker.y / hotspot.imageHeight) * 100;
                                return `
                        <div class="hotspot-marker ${marker.type}" 
                            style="position: absolute; left: ${xPercent}%; top: ${yPercent}%; width: 50px; height: 50px; font-size: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; cursor: pointer; transition: all 0.3s ease; background: ${marker.type === 'info' ? 'rgba(66, 153, 225, 0.9)' : 'rgba(72, 187, 120, 0.9)'}; border: 3px solid ${marker.type === 'info' ? '#2c5282' : '#22543d'}; transform: translate(-50%, -50%);"
                            data-text="${escapeHtml(marker.text)}"
                            ${marker.type === 'eye' && marker.image ? `data-image="${marker.image}"` : ''}
                            onclick="showHotspotTooltip(this)"
                            onmouseover="this.style.transform='translate(-50%, -50%) scale(1.2)'"
                            onmouseout="this.style.transform='translate(-50%, -50%) scale(1)'">
                            ${marker.type === 'info' ? 'ℹ️' : '👁️'}
                        </div>`;
                            }).join('')}
                    </div>
                </div>
            </section>
        `;
                        }
                    } else if (section.type === 'video') {
                        const video = videosList[section.videoIndex];
                        if (video) {
                            const videoSectionId = `video-section-${videoCounter}`;
                            html += `
            <!-- Video Section ${index + 1} -->
            <div class="video-spacer" data-section-id="${videoSectionId}" data-video-index="${section.videoIndex}" style="height: ${section.scrollDuration}vh; background: ${section.bgColor};"></div>
        `;
                            videoCounter++;
                        }
                    } else if (section.type === 'audio') {
                        html += `
                        <!-- Audio Section ${index + 1} -->
                        <section class="article-section audio-section" style="min-height: ${section.minHeight}vh; background: ${section.bgColor};">
                            <div class="article-content" style="text-align: center;">
                                <h2>${section.title}</h2>
                                <audio controls style="width: 100%; max-width: 600px; margin: 30px auto; display: block;">
                                    <source src="${section.audioUrl}" type="audio/wav">
                                    Your browser does not support the audio element.
                                </audio>
                            </div>
                        </section>
                    `;
                    }
                });

                return html;
            }

            // Helper function to escape HTML
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML.replace(/"/g, '&quot;');
            }


            // Generate HTML sections
            const htmlSections = generateHTMLSections(currentEffect, skyColor, filteredSceneContent);


            const exportedHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${exportName}</title>
${fileRequirementsComment}
    ${scriptIncludes}
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            overflow-x: hidden;
        }

        /* Article Sections */
        .article-section {
            min-height: 100vh;
            padding: 80px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
        }

        .article-content {
            max-width: 800px;
            width: 100%;
        }

        .article-content h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #1a202c;
        }

        .article-content h2 {
            font-size: 2.2em;
            margin-bottom: 20px;
            color: #2d3748;
        }

        .article-content h3 {
            font-size: 1.8em;
            margin-bottom: 16px;
            color: #2d3748;
        }

        .article-content p {
            font-size: 1.2em;
            margin-bottom: 20px;
            color: #4a5568;
        }

        .article-content img {
            width: 100%;
            border-radius: 8px;
            margin: 30px 0;
        }

        .article-content ul, .article-content ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        .article-content li {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #4a5568;
        }

        .article-content a {
            color: #4299e1;
            text-decoration: none;
        }

        .article-content a:hover {
            text-decoration: underline;
        }

        /* 3D Scene Containers */
       #main-3d-scene {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    z-index: 0;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

#main-3d-scene.active {
    opacity: 1;
}

/* 3D Section Spacers */
.scene-spacer {
    position: relative;
    height: 300vh;
    z-index: 1;
    background: transparent;
}

        .scene-container.active .scene-canvas {
            position: sticky;
            top: 0;
            height: 100vh;
            z-index: 10;
        }

        #scene-0 .scene-canvas { z-index: 10; }
        #scene-1 .scene-canvas { z-index: 20; }

        /* Text Overlays for 3D Sections */
        .text-overlay {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(${r}, ${g}, ${b}, ${overlayBgOpacity});
            color: #2d3748;
            padding: 40px 60px;
            border-radius: 12px;
            max-width: ${overlayWidth}%;
            text-align: center;
            font-size: 1.5em;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 100;
        }

        .text-overlay.visible {
            opacity: 1;
        }

        /* Scroll Progress Indicator */
        .scroll-progress {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(66, 153, 225, 0.1);
            border: 3px solid rgba(66, 153, 225, 0.3);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #4299e1;
            font-weight: bold;
            z-index: 1000;
        }

        .scroll-progress.active {
            display: flex;
        }

        @media (max-width: 768px) {
            .article-content h1 {
                font-size: 2em;
            }
            .article-content h2 {
                font-size: 1.6em;
            }
            .article-content p, .article-content li {
                font-size: 1em;
            }
            .text-overlay {
                padding: 20px 30px;
                font-size: 1.2em;
            }
        }
    </style>

    <script>
        // Store all 3D section data
        const ANIMATED_SECTIONS = ${JSON.stringify(getAnimatedSectionsData())};
    
    // Video scroll controller (standalone, no A-Frame dependency)
    class VideoScrollController {
        constructor() {
            this.videoSections = [];
            this.currentVideoSection = null;
            this.onScroll = this.onScroll.bind(this);
            this.init();
        }
        
        init() {
            // Find all video spacers
            const videoSpacers = document.querySelectorAll('.video-spacer');
            videoSpacers.forEach((spacer, index) => {
                const videoIndex = parseInt(spacer.dataset.videoIndex);
                const sectionData = ANIMATED_SECTIONS.find(s => s.type === 'video' && s.id === spacer.dataset.sectionId);
                
                if (sectionData) {
                    // Create video element
                    const videoEl = document.createElement('video');
                    videoEl.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100vh; object-fit: cover; z-index: 0; opacity: 0; transition: opacity 0.3s;';
                    videoEl.muted = true;
                    videoEl.playsInline = true;
                    videoEl.preload = 'auto';
                    
                    // CRITICAL: Set src AFTER adding load listeners
                    videoEl.addEventListener('loadedmetadata', () => {
                        console.log('Video loaded:', sectionData.videoFilename);
                        this.videoSections.push({
                            spacer: spacer,
                            videoEl: videoEl,
                            duration: videoEl.duration,
                            scrollDuration: sectionData.scrollDuration,
                            ready: true
                        });
                        
                        // Force initial frame render
                        videoEl.currentTime = 0.1;
                        
                        // Trigger initial scroll check after video is ready
                        this.onScroll();
                    });
                    
                    videoEl.addEventListener('error', (e) => {
                        console.error('Video load error:', e, 'for file:', sectionData.videoFilename);
                        console.error('Make sure the video file is in the same folder as this HTML file');
                    });
                    
                    // Add to DOM first
                    document.body.appendChild(videoEl);
                    
                    // Set src LAST
                    videoEl.src = sectionData.videoFilename;
                    videoEl.load(); // Force load
                }
            });
            
            window.addEventListener('scroll', this.onScroll);
            this.onScroll(); // Initial check
        }
        
        onScroll() {
            const vh = window.innerHeight;
            let activeSection = null;
            
            this.videoSections.forEach(section => {
                if (!section.ready) return; // Skip if video not loaded yet
                
                const rect = section.spacer.getBoundingClientRect();
                const isActive = rect.top < vh && rect.bottom > 0;
                
                if (isActive) {
                    activeSection = section;
                    section.videoEl.style.opacity = '1';
                    
                    // Calculate progress (0 to 1)
                    const sectionTop = rect.top;
                    const sectionHeight = rect.height;
                    const scrollableHeight = vh + sectionHeight;
                    const scrolled = vh - sectionTop;
                    const progress = Math.max(0, Math.min(1, scrolled / scrollableHeight));
                    
                    // Set video time based on scroll
                    const targetTime = progress * section.duration;
                    
                    // Only update if difference is significant (prevents jitter)
                    if (Math.abs(section.videoEl.currentTime - targetTime) > 0.1) {
                        section.videoEl.currentTime = targetTime;
                    }
                } else {
                    section.videoEl.style.opacity = '0';
                }
            });
            
            this.currentVideoSection = activeSection;
        }
    }
    
    // Initialize video controller when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            new VideoScrollController();
        });
    } else {
        new VideoScrollController();
    }

    // Unified scroll-based 3D animation component
    AFRAME.registerComponent('unified-scroll-animator', {
        init: function () {
            this.cameraEl = this.el;
            this.currentSection = null;
            this.currentAnimation = null;
            this.currentFrame = 0;
            this.textDisplayRange = 10;
            
            // Get all scene spacers
            this.sceneSpacer = document.querySelectorAll('.scene-spacer');
            this.sceneContainer = document.getElementById('main-3d-scene');
            
            // Bind scroll listener
            this.onScroll = this.onScroll.bind(this);
            window.addEventListener('scroll', this.onScroll);
            
            // Initial check
            this.onScroll();
        },

        onScroll: function() {
            const vh = window.innerHeight;
            let activeSection = null;
            let activeSpacer = null;
            
            // Find which scene spacer is currently in view
            this.sceneSpacer.forEach((spacer) => {
                const rect = spacer.getBoundingClientRect();
                const isActive = rect.top < vh && rect.bottom > 0;
                
                if (isActive) {
                    activeSection = spacer.dataset.sectionId;
                    activeSpacer = spacer;
                }
            });
            
            // Show/hide 3D scene
            if (activeSection) {
                this.sceneContainer.classList.add('active');
                
                // Switch animation if section changed
                if (this.currentSection !== activeSection) {
                    this.loadAnimation(activeSection);
                }
                
                // Calculate scroll progress within this section
                const rect = activeSpacer.getBoundingClientRect();
                const sectionTop = rect.top;
                const sectionHeight = rect.height;
                const progress = Math.max(0, Math.min(1, 
                    (vh - sectionTop) / (vh + sectionHeight)
                ));
                
                // Update camera position
                this.updateCamera(progress);
                
                // Update text overlay
                this.updateTextOverlay(activeSection);
                
            } else {
                this.sceneContainer.classList.remove('active');
                this.hideTextOverlay();
            }
        },

        loadAnimation: function(sectionId) {
            this.currentSection = sectionId;
            
            // Find animation data by matching the id property
            const animData = ANIMATED_SECTIONS.find(s => s.type === '3d' && s.id === sectionId);
            
            if (!animData || !animData.recording) {
                console.error('No animation data for section:', sectionId);
                return;
            }
            
            this.currentAnimation = animData.recording;
            this.textSlides = animData.textSlides || [];
            this.hasTextSlides = animData.hasTextSlides || false;
            
            // Parse steps
            this.steps = Object.keys(this.currentAnimation).filter(key => key.startsWith('step_'));
            this.totalFrames = this.currentAnimation.step_1.frameCount;
            
            // Jump to first frame of new animation
            this.jumpToFrame(0);
        },

        updateCamera: function(progress) {
            if (!this.currentAnimation || !this.steps.length) return;
            
            const targetFrame = Math.floor(progress * (this.totalFrames - 1));
            this.currentFrame = targetFrame;
            this.jumpToFrame(targetFrame);
        },

        jumpToFrame: function(frameIndex) {
            if (!this.currentAnimation || !this.steps.length) return;
            if (frameIndex < 0 || frameIndex >= this.totalFrames) return;

            const stepKey = this.steps[0];
            const stepData = this.currentAnimation[stepKey];
            
            if (!stepData || !stepData.position || !stepData.position[frameIndex]) return;
            
            const pos = stepData.position[frameIndex];
            const rot = stepData.rotation[frameIndex];

            this.cameraEl.setAttribute('position', pos[0] + ' ' + pos[1] + ' ' + pos[2]);
            
            let quaternion = new THREE.Quaternion();
            quaternion.setFromEuler(new THREE.Euler(
                THREE.MathUtils.degToRad(rot[0]),
                THREE.MathUtils.degToRad(rot[1]),
                THREE.MathUtils.degToRad(rot[2]),
                'YXZ'
            ));
            this.cameraEl.object3D.quaternion.slerp(quaternion, 0.1);
        },

        updateTextOverlay: function(sectionId) {
            if (!this.hasTextSlides || !this.textSlides || this.textSlides.length === 0) {
                this.hideTextOverlay();
                return;
            }

            const currentFrame = this.currentFrame + 1;
            let foundText = false;

            this.textSlides.forEach((slide) => {
                const frameNumber = slide.frameNumber;
                const durationFrames = slide.durationFrames;
                const text = slide.text;
                const startFrame = frameNumber - this.textDisplayRange;
                const endFrame = frameNumber + durationFrames + this.textDisplayRange;

                if (currentFrame >= startFrame && currentFrame <= endFrame) {
                    const progress = this.calculateProgress(currentFrame, frameNumber, durationFrames);
                    this.showTextOverlay(text, progress, sectionId);
                    foundText = true;
                }
            });

            if (!foundText) {
                this.hideTextOverlay();
            }
        },

        calculateProgress: function(currentFrame, targetFrame, durationFrames) {
            const fadeInDuration = this.textDisplayRange;
            const fadeOutDuration = this.textDisplayRange;
            const fadeOutStart = targetFrame + durationFrames;

            if (currentFrame < targetFrame) {
                return 0.5 * (currentFrame - (targetFrame - fadeInDuration)) / fadeInDuration;
            } else if (currentFrame >= targetFrame && currentFrame < fadeOutStart) {
                return 1;
            } else if (currentFrame >= fadeOutStart && currentFrame <= fadeOutStart + fadeOutDuration) {
                return 1 + 0.5 * ((currentFrame - fadeOutStart) / fadeOutDuration);
            } else {
                return 0;
            }
        },

        showTextOverlay: function(text, progress, sectionId) {
            let textOverlay = document.querySelector('.text-overlay[data-section="' + sectionId + '"]');
            if (!textOverlay) {
                textOverlay = document.createElement('div');
                textOverlay.className = 'text-overlay';
                textOverlay.setAttribute('data-section', sectionId);
                document.body.appendChild(textOverlay);
            }

            textOverlay.innerHTML = text;
            textOverlay.style.opacity = Math.max(0, Math.min(1, progress * 2));
            
            if (progress >= 0.5 && progress <= 1) {
                textOverlay.classList.add('visible');
            } else {
                textOverlay.classList.remove('visible');
            }
        },

        hideTextOverlay: function() {
            const textOverlays = document.querySelectorAll('.text-overlay');
            textOverlays.forEach(overlay => {
                overlay.classList.remove('visible');
                overlay.style.opacity = 0;
            });
        },

        remove: function() {
            window.removeEventListener('scroll', this.onScroll);
        }
    });
    <\/script>
</head>
<body>
    <div class="scroll-progress" id="scroll-progress">0%</div>

    ${articleStructure.sections.some(s => s.type === '3d') ? `<div id="main-3d-scene">
        <a-scene embedded${currentEffect && currentEffect !== 'none' ? ` post-processing="effect: ${currentEffect}"` : ''}>
            <a-entity 
                unified-scroll-animator
                video-scroll-controller
                camera 
                position="0 1.6 0">
            </a-entity>
            
            <a-sky color="${skyColor}"></a-sky>
            ${filteredSceneContent}
        </a-scene>
    </div>` : ''}
${htmlSections}

    <script>
        // Hotspot interaction
        function showHotspotTooltip(element) {
            const text = element.getAttribute('data-text');
            const image = element.getAttribute('data-image');
            
            // Remove existing tooltips
            document.querySelectorAll('.hotspot-tooltip-popup').forEach(t => t.remove());
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'hotspot-tooltip-popup';
            tooltip.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 10000; max-width: 600px;';
            
            let content = '<div style="display: flex; gap: 20px; align-items: flex-start;">';
            
            if (image) {
                content += '<img src="' + image + '" style="width: 250px; height: auto; border-radius: 8px; flex-shrink: 0;">';
            }
            
            content += '<div style="flex: 1;"><p style="margin: 0 0 20px 0; font-size: 16px; line-height: 1.6;">' + text + '</p>';
            content += '<button class="close-hotspot-btn" style="background: #4299e1; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">Close</button></div>';
            content += '</div>';
            
            tooltip.innerHTML = content;
            document.body.appendChild(tooltip);
            
            // Add click handler to close button
            tooltip.querySelector('.close-hotspot-btn').onclick = () => {
                tooltip.remove();
            };
        }
        // Update scroll progress indicator
        window.addEventListener('scroll', () => {
            const scrollProgress = document.getElementById('scroll-progress');
            const totalHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = Math.round((window.scrollY / totalHeight) * 100);
            scrollProgress.textContent = progress + '%';
            
            if (window.scrollY > 100) {
                scrollProgress.classList.add('active');
            } else {
                scrollProgress.classList.remove('active');
            }
        });
    <\/script>
</body>
</html>`;;

            // Download the file
            const blob = new Blob([exportedHTML], { type: 'text/html' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = sanitizedFilename + '.html';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Show success message
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:#28a745;color:white;padding:15px 30px;border-radius:5px;z-index:10001;';
            overlay.textContent = `Complete article exported as "${sanitizedFilename}.html"`;
            document.body.appendChild(overlay);
            setTimeout(() => overlay.remove(), 3000);

            console.log('Complete article exported successfully!');
            console.log('- Total sections:', articleStructure.sections.length);
            console.log('- Article sections:', articleStructure.sections.filter(s => s.type === 'article').length);
            console.log('- 3D sections:', articleStructure.sections.filter(s => s.type === '3d').length);
        }



        // Helper function to get 3D sections data
        function getAnimatedSectionsData() {
            const cameraEntity = document.querySelector('[camera-movement-recorder]');
            const allRecordings = cameraEntity?.components['camera-movement-recorder']?.allRecordings || [];
            const data = [];

            let sceneCounter = 0;
            let videoCounter = 0;

            articleStructure.sections.forEach((section) => {
                if (section.type === '3d') {
                    const recording = allRecordings[section.recordingIndex];
                    if (!recording) return;

                    data.push({
                        type: '3d',
                        id: `scene-${sceneCounter}`,
                        name: section.name,
                        recording: recording,
                        textSlides: section.textSlides || [],
                        hasTextSlides: section.hasTextSlides || false
                    });

                    sceneCounter++;
                } else if (section.type === 'video') {
                    const video = videosList[section.videoIndex];
                    if (!video) return;

                    data.push({
                        type: 'video',
                        id: `video-section-${videoCounter}`,
                        name: section.name,
                        videoSrc: video.filename,  // Use filename instead of blob URL
                        videoFilename: video.filename,
                        videoDuration: video.duration,
                        scrollDuration: section.scrollDuration
                    });

                    videoCounter++;
                }
            });

            return data;
        }

        // ═══════════════════════════════════════════════════════════════
        // EXPORT ARTICLE MODAL
        // ═══════════════════════════════════════════════════════════════

        function openExportArticleModal() {
            if (articleStructure.sections.length === 0) {
                showNotification('Please add at least one section before exporting.', 'warning');
                return;
            }

            // // Check if there are video sections
            // const hasVideos = articleStructure.sections.some(s => s.type === 'video');
            // if (hasVideos) {
            //     showNotification('Note: Videos will be embedded as base64 data. Large videos may result in very large HTML files.', 'info', 5000);
            // }

            const modal = document.getElementById('export-article-modal');
            const input = document.getElementById('export-article-name-input');
            input.value = 'my-article';
            modal.classList.add('active');
            input.focus();
            input.select();
        }
        function closeExportArticleModal() {
            document.getElementById('export-article-modal').classList.remove('active');
        }

        function confirmExportArticle() {
            const exportName = document.getElementById('export-article-name-input').value.trim() || 'my-article';
            closeExportArticleModal();

            // Call the existing export function with the name
            exportCompleteArticleWithName(exportName);
        }

        // ═══════════════════════════════════════════════════════════════
        // ADD SLIDE MODAL
        // ═══════════════════════════════════════════════════════════════

        function openAddSlideModal() {
            const scrollEntity = document.querySelector('[scroll-animator]');
            const scrollComponent = scrollEntity?.components['scroll-animator'];

            if (!scrollComponent || scrollComponent.currentRecordingIndex < 0) {
                alert('Please select a camera path first before adding slides.');
                return;
            }

            const modal = document.getElementById('add-slide-modal');

            // Initialize Quill editor if not already done
            if (!newSlideQuill) {
                newSlideQuill = new Quill('#new-slide-editor', {
                    theme: 'snow',
                    placeholder: 'Enter slide text...',
                    modules: {
                        toolbar: [
                            ['bold', 'italic', 'underline'],
                            [{ 'color': [] }, { 'background': [] }],
                            [{ 'align': [] }],
                            ['image'],
                            ['clean']
                        ]
                    }
                });
            }

            // Clear inputs
            document.getElementById('new-slide-frame').value = '';
            document.getElementById('new-slide-duration').value = '';
            newSlideQuill.setText('');

            modal.classList.add('active');
        }

        function closeAddSlideModal() {
            document.getElementById('add-slide-modal').classList.remove('active');
        }

        function confirmAddSlide() {
            const frameNumber = document.getElementById('new-slide-frame').value;
            const duration = document.getElementById('new-slide-duration').value;
            const textContent = newSlideQuill.root.innerHTML;

            if (!frameNumber || !duration) {
                showNotification('Please enter both frame number and duration.', 'warning');
                return;
            }

            const scrollEntity = document.querySelector('[scroll-animator]');
            const scrollComponent = scrollEntity?.components['scroll-animator'];

            if (!scrollComponent) return;

            // Create the slide in the UI
            const container = document.querySelector('.text-inputs-container');

            // Remove "no slides" message if present
            const noSlidesMsg = container.querySelector('p[style*="color: #a0aec0"]');
            if (noSlidesMsg) {
                noSlidesMsg.remove();
            }

            const slideCount = container.querySelectorAll('.text-input-row').length + 1;
            const editorId = 'editor-' + Date.now();

            const newTextInput = document.createElement('div');
            newTextInput.className = 'text-input-row';
            newTextInput.innerHTML = `
        <label class="slideTitle">Slide: ${slideCount}</label>
        <input type="number" class="frameNumber" placeholder="Frame number..." value="${frameNumber}">
        <input type="number" class="durationFrames" placeholder="Duration in frames..." min="1" value="${duration}">
        <div class="quill-editor-container">
            <div id="${editorId}" class="scrollableText"></div>
        </div>
        <button class="delete-slide-button">Delete</button>
    `;
            container.appendChild(newTextInput);

            // Initialize Quill editor for this slide
            const quill = new Quill('#' + editorId, {
                theme: 'snow',
                placeholder: 'Enter text...',
                modules: {
                    toolbar: [
                        ['bold', 'italic', 'underline'],
                        [{ 'color': [] }, { 'background': [] }],
                        [{ 'align': [] }],
                        ['image'],
                        ['clean']
                    ]
                }
            });

            // Set the content
            quill.root.innerHTML = textContent;

            // Store quill instance
            newTextInput.querySelector('.quill-editor-container').quillInstance = quill;

            // Add delete button listener
            const deleteButton = newTextInput.querySelector('.delete-slide-button');
            deleteButton.addEventListener('click', () => {
                scrollComponent.deleteSlide(newTextInput);
            });

            // Add auto-save listeners
            const frameNumberInput = newTextInput.querySelector('.frameNumber');
            const durationInput = newTextInput.querySelector('.durationFrames');

            frameNumberInput.addEventListener('input', () => {
                scrollComponent.autoSaveCurrentSlides();
            });

            durationInput.addEventListener('input', () => {
                scrollComponent.autoSaveCurrentSlides();
            });

            quill.on('text-change', () => {
                scrollComponent.autoSaveCurrentSlides();
            });

            // Auto-save
            scrollComponent.autoSaveCurrentSlides();

            closeAddSlideModal();
        }

        function openSaveSceneModal() {
            const modal = document.getElementById('save-scene-modal');
            const input = document.getElementById('save-scene-name-input');
            input.value = 'My 3D Scene Project';
            modal.classList.add('active');
            input.focus();
            input.select();

            // Allow Enter key to save
            input.onkeypress = function (e) {
                if (e.key === 'Enter') {
                    confirmSaveScene();
                }
            };
        }

        function closeSaveSceneModal() {
            document.getElementById('save-scene-modal').classList.remove('active');
        }

        function confirmSaveScene() {
            const projectName = document.getElementById('save-scene-name-input').value.trim();

            if (!projectName) {
                showNotification('Please enter a project name', 'warning');
                return;
            }

            closeSaveSceneModal();

            // Trigger the save in scene-manager
            const sceneManager = window.sceneManagerInstance;
            if (sceneManager) {
                sceneManager.saveSceneWithName(projectName);
            }
        }

        function openDeleteProjectsModal() {
            const sceneManager = window.sceneManagerInstance;

            if (!sceneManager || !sceneManager.currentProjectId) {
                showNotification('Please select a project to delete', 'warning');
                return;
            }

            const modal = document.getElementById('delete-projects-modal');
            const message = document.getElementById('delete-projects-message');

            message.textContent = `Are you sure you want to delete this project? This action cannot be undone.`;

            modal.classList.add('active');
        }

        function closeDeleteProjectsModal() {
            document.getElementById('delete-projects-modal').classList.remove('active');
        }

        function confirmDeleteProjects() {
            closeDeleteProjectsModal();

            // Trigger delete in scene-manager
            const sceneManager = window.sceneManagerInstance;
            if (sceneManager) {
                sceneManager.deleteSelectedProjects();
            }
        }


        // ═══════════════════════════════════════════════════════════════
        // CENTRALIZED NOTIFICATION SYSTEM
        // ═══════════════════════════════════════════════════════════════

        function showNotification(message, type = 'info', duration = 3000) {
            const overlay = document.getElementById('notification-overlay');
            const box = document.getElementById('notification-box');
            const icon = document.getElementById('notification-icon');
            const messageEl = document.getElementById('notification-message');

            // Set icon based on type
            const icons = {
                success: '✓',
                error: '✕',
                warning: '⚠',
                info: 'ℹ'
            };

            // Update content
            icon.textContent = icons[type] || icons.info;
            messageEl.textContent = message;

            // Update box class
            box.className = 'notification-box ' + type;

            // Show notification
            overlay.classList.add('active');

            // Auto-hide after duration
            setTimeout(() => {
                overlay.classList.remove('active');
            }, duration);

            // Allow clicking overlay to dismiss
            overlay.onclick = function (e) {
                if (e.target === overlay) {
                    overlay.classList.remove('active');
                }
            };
        }


        // ═══════════════════════════════════════════════════════════════
        // VIDEO MANAGEMENT
        // ═══════════════════════════════════════════════════════════════

        function openAddVideoModal() {
            const modal = document.getElementById('add-video-modal');
            document.getElementById('video-title-input').value = '';
            document.getElementById('video-upload-input').value = '';
            document.getElementById('video-preview-container').style.display = 'none';
            modal.classList.add('active');
        }

        function closeAddVideoModal() {
            document.getElementById('add-video-modal').classList.remove('active');
        }

        function confirmAddVideo() {
            const title = document.getElementById('video-title-input').value.trim();
            const fileInput = document.getElementById('video-upload-input');
            const file = fileInput.files[0];

            if (!title) {
                showNotification('Please enter a video title', 'warning');
                return;
            }

            if (!file) {
                showNotification('Please select a video file', 'warning');
                return;
            }

            // Use blob URL instead of base64
            const videoUrl = URL.createObjectURL(file);

            // Create video element to get metadata
            const video = document.createElement('video');
            video.src = videoUrl;

            video.addEventListener('loadedmetadata', function () {
                const videoId = 'video-' + Date.now();

                videosList.push({
                    id: videoId,
                    title: title,
                    src: videoUrl,
                    filename: file.name,  // Store filename for export instructions
                    duration: video.duration,
                    width: video.videoWidth,
                    height: video.videoHeight
                });

                updateVideosList();
                closeAddVideoModal();
                showNotification(`Video "${title}" added successfully`, 'success');
            });
        }


        function updateVideosList() {
            const container = document.getElementById('videos-list');

            if (videosList.length === 0) {
                container.innerHTML = '<p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">No videos yet. Click "Add Video" to upload one.</p>';
                return;
            }

            let html = '';
            videosList.forEach((video) => {
                const isSelected = selectedVideoId === video.id;
                html += `
            <div class="project-list-item ${isSelected ? 'selected' : ''}" 
                onclick="selectVideo('${video.id}')"
                style="cursor: pointer;">
                <div class="project-name">${video.title}</div>
                <div class="project-date">${video.duration.toFixed(1)}s, ${video.width}×${video.height}</div>
            </div>
        `;
            });

            container.innerHTML = html;
        }

        function selectVideo(videoId) {
            selectedVideoId = videoId;
            updateVideosList();
        }

        function deleteSelectedVideo() {
            if (!selectedVideoId) {
                showNotification('Please select a video to delete', 'warning');
                return;
            }

            const video = videosList.find(v => v.id === selectedVideoId);
            if (!video) return;

            if (!confirm(`Delete video "${video.title}"?`)) {
                return;
            }

            videosList = videosList.filter(v => v.id !== selectedVideoId);
            selectedVideoId = null;

            updateVideosList();
            showNotification('Video deleted', 'success');
        }

        function openVideoSectionModal(index = -1) {
            articleStructure.currentEditIndex = index;
            const modal = document.getElementById('video-section-modal');
            const select = document.getElementById('video-section-select');

            // Populate videos
            select.innerHTML = '<option value="">Select a video...</option>';
            videosList.forEach((video, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = video.title;
                select.appendChild(option);
            });

            if (index >= 0) {
                const section = articleStructure.sections[index];
                document.getElementById('video-section-name').value = section.name;
                select.value = section.videoIndex;
                document.getElementById('video-section-bg').value = section.bgColor;
                document.getElementById('video-section-duration').value = section.scrollDuration;
                document.getElementById('video-section-duration-value').textContent = section.scrollDuration;
            } else {
                document.getElementById('video-section-name').value = '';
                select.value = '';
                document.getElementById('video-section-bg').value = '#000000';
                document.getElementById('video-section-duration').value = 300;
                document.getElementById('video-section-duration-value').textContent = '300';
            }

            modal.classList.add('active');
        }

        function closeVideoSectionModal() {
            document.getElementById('video-section-modal').classList.remove('active');
            articleStructure.currentEditIndex = -1;
        }

        function saveVideoSection() {
            const videoIndex = parseInt(document.getElementById('video-section-select').value);

            if (videoIndex === '' || isNaN(videoIndex)) {
                showNotification('Please select a video', 'warning');
                return;
            }

            const section = {
                type: 'video',
                name: document.getElementById('video-section-name').value,
                videoIndex: videoIndex,
                bgColor: document.getElementById('video-section-bg').value,
                scrollDuration: parseInt(document.getElementById('video-section-duration').value)
            };

            if (articleStructure.currentEditIndex >= 0) {
                articleStructure.sections[articleStructure.currentEditIndex] = section;
            } else {
                articleStructure.sections.push(section);
            }

            updateSectionsList();
            closeVideoSectionModal();
        }


    </script>

    <script id="embedded-json-scroll" type="application/json"></script>
    <script id="embedded-text-slides" type="application/json">[]</script>
</head>

<body>
    <div id="main-scene">
        <!-- ═══════════════════════════════════════════════════════════════
             TOP NAVIGATION BAR
             ═══════════════════════════════════════════════════════════════ -->
        <div id="buttons-container">
            <img src="/icons/logo_new.png" alt="Logo" style="height: 40px; margin-right: 16px; cursor: pointer;" onclick="window.location.href='/'">
            <button onclick="togglePanel('save-load-panel')">File</button>
            <button onclick="togglePanel('scene-elements-panel')">Scene Elements</button>
            <button onclick="togglePanel('hotspots-panel')">Image & Hotspots</button>
            <button onclick="togglePanel('videos-panel')">Scrollable Videos</button>
            <button onclick="togglePanel('audio-panel')">Audio</button>
            <button onclick="togglePanel('camera-panel')">Camera Paths</button>
            <button onclick="togglePanel('scroll-panel')">Text Slides</button>
            <button onclick="togglePanel('effects-panel')">Effects</button>
            <button onclick="togglePanel('article-structure-panel')">Article Builder</button>         
            
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             CONTROLS TOOLBAR
             ═══════════════════════════════════════════════════════════════ -->
        <div class="controls-container">
            <!-- Background Control -->
            <div class="transform-icon" id="backgroundChange" title="Change Background Color">
                <img src="icons/background.png" alt="Background">
            </div>

            <!-- Grid Toggle (Replaces gridEnable and gridDisable) -->
            <div class="transform-icon active" id="gridToggle" title="Disable Grid">
                <img src="icons/grid-enable.png" alt="Grid" id="gridIcon">
            </div>

            <div class="controls-separator"></div>

            <!-- Movement Controls -->
            <div class="transform-icon" id="wasd" title="WASD Movement">
                <img src="icons/wasd.png" alt="WASD">
            </div>

            <div class="transform-icon" id="fly" title="Fly Mode">
                <img src="icons/fly.png" alt="Fly">
            </div>

            <div class="controls-separator"></div>

            <!-- Transform Controls -->
            <div class="transform-controls">
                <div id="translateIcon" class="transform-icon" title="Translate">
                    <img src="icons/transform.png" alt="Translate">
                </div>
                <div id="rotateIcon" class="transform-icon" title="Rotate">
                    <img src="icons/rotate.png" alt="Rotate">
                </div>
                <div id="scaleIcon" class="transform-icon" title="Scale">
                    <img src="icons/scale.png" alt="Scale">
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
        ASSETS PANEL
        ═══════════════════════════════════════════════════════════════ -->
        <div id="scene-elements-panel" class="panel">
            <h3>Scene Elements</h3>

            <!-- 3D Assets & Images Subsection -->


            <div class="content-block">
                <label>Upload Assets</label>
                <input type="file" id="asset-loader" accept=".gltf,.glb,.splat,.jpg,.jpeg,.png,.gif,.webp" multiple>
                <p>Supported formats: 3D (.splat, .gltf, .glb) | Images (.jpg, .png, .gif, .webp)</p>
            </div>

            <label>Samples</label>
            <div class="button-container">
                <button id="preloadGS">Gaussian Splat</button>
                <button id="preloadGLTF">GLTF</button>
            </div>
            <hr>

            <!-- Text Annotations Subsection -->
            <h3>3D Text Annotations </h3>
            <div class="content-block">
                <p>Create and manage text annotations in your 3D scene</p>

                <div class="button-container">
                    <button id="create-annotation-btn">Create Annotation</button>
                    <button id="edit-annotation-btn">Edit Selected</button>
                </div>

                <div class="button-container" style="margin-top: 0;">
                    <button id="delete-annotation-btn">Delete Selected</button>
                </div>
            </div>

            <div class="content-block">
                <h4>Your Annotations</h4>
                <div id="annotations-list">
                    <p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">
                        No annotations yet. Click "Create Annotation" to add one.
                    </p>
                </div>
            </div>
        </div>



        <!-- ═══════════════════════════════════════════════════════════════
             CAMERA RECORDER PANEL
             ═══════════════════════════════════════════════════════════════ -->
        <div id="camera-panel" class="panel">
            <h3>Camera Paths</h3>

            <!-- Live Path Recording Section -->
            <div class="content-block">
                <h4>Record Live Path</h4>
                <p>Record your camera movement in real-time</p>

                <p>Current Frame: <span id="currentFrame">0</span></p>
                <p>Total Frames: <span id="frameCount">0</span></p>
                <p>Duration: <span id="duration">0.00</span>s</p>

                <div class="button-container">
                    <button id="startButton">Start Recording</button>
                    <button id="endButton">End Recording</button>
                </div>

                <div class="button-container">
                    <button id="play-current-recording-btn">
                        Play Current
                    </button>
                    <button id="save-current-as-recording">
                        Save Path
                    </button>
                </div>
            </div>

            <hr>

            <!-- Manual Waypoints Section -->
            <div class="content-block">
                <h4>Keyframe Path</h4>
                <p>Move camera freely and add keyframe positions</p>

                <div class="button-container">
                    <button id="add-keyframe-btn" style="background: #48bb78;">
                        Add Camera
                    </button>
                    <button id="clear-keyframes-btn" style="background: #f56565;">
                        Clear All
                    </button>
                </div>

                <div id="keyframes-list">
                    <div style="color:#a0aec0; text-align:center; padding:20px 0; font-style: italic;">
                        No cameras added yet
                    </div>
                </div>

                <button id="play-manual-animation-btn">
                    Play Camera Path
                </button>
                <button id="save-manual-as-recording">
                    Save as Path
                </button>
            </div>

            <hr>

            <!-- Saved Recordings Section -->
            <div class="content-block">
                <h4>Saved Paths</h4>
                <p>Select and play previously saved camera paths</p>

                <select id="saved-recordings-select">
                    <option value="">Select a saved path...</option>
                </select>

                <button id="play-saved-recording-btn">
                    Play Selected
                </button>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             SCROLLYTELLING PANEL
             ═══════════════════════════════════════════════════════════════ -->
        <div id="scroll-panel" class="panel">
            <h3>Text Slides</h3>

            <!-- Camera Recording Selection -->
            <div class="content-block">
                <h4>Camera Path</h4>

                <label for="recording-select-scroll" style="display: none;">Select Path</label>
                <select id="recording-select-scroll" style="display: none;">
                    <option value="">Select a camera path...</option>
                </select>

                <p>Current Frame: <span id="currentFrame2">0</span></p>
                <p>Total Frames: <span id="frameCount2">0</span></p>
                <p>Duration: <span id="duration2">0.00</span>s</p>

                <div class="slider-container">
                    <div class="slider-header">
                        <label>Animation Speed</label>
                        <span class="slider-value speed-value">1</span>
                    </div>
                    <input type="range" id="speed-slider" min="1" max="50" value="1">
                </div>

                <div class="slider-container">
                    <div class="slider-header">
                        <label>Frame Position</label>
                        <span class="slider-value" id="frame-slider-value">0</span>
                    </div>
                    <input type="range" id="frame-slider" min="0" max="0" value="0">
                </div>
            </div>

            <hr>

            <!-- Text Slides Section -->
            <div class="content-block">
                <h4>Sliding Text Options</h4>

                <label for="direction-select">Text Direction</label>
                <select id="direction-select">
                    <option value="bottom-to-center">Bottom to Top</option>
                    <option value="left-to-center">Left to Right</option>
                    <option value="right-to-center">Right to Left</option>
                    <option value="top-to-center">Top to Bottom</option>
                </select>

                <!-- ADD THESE NEW CONTROLS -->
                <div class="input-row" style="margin-top: 16px;">
                    <div class="input-group">
                        <label>Background Color</label>
                        <div style="position: relative; display: inline-block;">
                            <!-- Custom clickable icon -->
                            <img src="icons/color.png" alt="Pick background color" id="overlay-bg-color-icon" style="
                    width: 38px;
                    height: 38px;
                    cursor: pointer;
                    border: 1px solid #cbd5e0;
                    border-radius: 6px;
                    padding: 4px;
                    background: #f7fafc;
                ">

                        </div>
                    </div>

                    <div class="input-group">
                        <label>BG Opacity (%)</label>
                        <input type="number" id="overlay-bg-opacity" value="95" min="0" max="100">
                    </div>
                </div>

                <!-- Keep the real color input but hide it -->
                <input type="color" id="overlay-bg-color" value="#ffffff" style="display: none;">

                <div class="slider-container">
                    <div class="slider-header">
                        <label>Overlay Width (%)</label>
                        <span class="slider-value" id="overlay-width-value">80</span>
                    </div>
                    <input type="range" id="overlay-width-slider" min="30" max="100" value="80">
                </div>
                <!-- END NEW CONTROLS -->

                <div class="text-inputs-container">
                    <p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">
                        No slides added yet. Click "Add Slide" to create text overlays.
                    </p>
                </div>

                <button id="add-slide-button">Add Slide</button>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
            ARTICLE STRUCTURE PANEL
            ═══════════════════════════════════════════════════════════════ -->
        <div id="article-structure-panel" class="panel">
            <h3>Article Builder</h3>

            <button id="export-article-btn" style="margin-bottom: 0;">
                Export Article as HTML
            </button>

            <hr>


            <div class="content-block">
                <h4>Add Sections</h4>
                <p>Combine text, 3D scenes, images, and videos</p>


                <div class="button-container">
                    <button id="add-article-section-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                        <span>Add Text</span>
                    </button>
                    <button id="add-3d-section-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path
                                d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z">
                            </path>
                            <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                            <line x1="12" y1="22.08" x2="12" y2="12"></line>
                        </svg>
                        <span>Add 3D Scene</span>
                    </button>
                </div>

                <div class="button-container" style="margin-top: 0;">
                    <button id="add-hotspot-section-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                            <circle cx="12" cy="10" r="3"></circle>
                        </svg>
                        <span>Add Hotspots</span>
                    </button>
                    <button id="add-video-section-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="23 7 16 12 23 17 23 7"></polygon>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                        </svg>
                        <span>Add Video</span>
                    </button>
                </div>

                <div class="button-container" style="margin-top: 0;">
                    <button id="add-audio-section-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        </svg>
                        <span>Add Audio</span>
                    </button>
                </div>

            </div>

            <hr>

            <div class="content-block">
                <h4>Your Sections</h4>
                <div id="sections-list">
                    <p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">
                        No sections yet. Click buttons above to start building your article.
                    </p>
                </div>
            </div>
        </div>
        <!-- ═══════════════════════════════════════════════════════════════
             EFFECTS PANEL
             ═══════════════════════════════════════════════════════════════ -->
        <div id="effects-panel" class="panel">
            <h3>Visual Effects</h3>

            <div class="content-block">
                <h4>Post-Processing Effects</h4>
                <label for="effect-select">Choose Effect</label>
                <select id="effect-select">
                    <option value="none">None</option>
                    <option value="sketchy-pencil">Sketchy Pencil</option>
                    <option value="halftone">Halftone</option>
                    <option value="old-film">Old Film</option>
                    <option value="pixel">Pixel</option>
                    <option value="glitch">Glitch</option>
                    <option value="sobel">Sobel</option>
                    <option value="bloom">Bloom</option>
                    <option value="dot-screen">Dot Screen</option>
                    <option value="volumetric-light">Volumetric Light</option>
                    <option value="afterimage">Afterimage</option>
                    <option value="bad-tv">Bad TV</option>
                    <option value="custom-outline">Custom Outline</option>
                    <option value="moebius">Moebius</option>
                </select>
                <div id="effect-params"></div>
            </div>

            <hr>

            <div class="content-block">
                <h4>Gaussian Splat Effects</h4>

                <label for="colorEffect">Color Effect</label>
                <select id="colorEffect">
                    <option value="0">Normal</option>
                    <option value="1">Grayscale</option>
                    <option value="2">Single Color + White</option>
                </select>

                <label for="singleColor">Single Color</label>
                <input type="color" id="singleColor" value="#FF0000">

                <div class="slider-container">
                    <div class="slider-header">
                        <label>Display Radius</label>
                        <span class="slider-value" id="displayRadiusValue">1.0</span>
                    </div>
                    <input type="range" id="displayRadius" min="0.1" max="10.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             HOTSPOTS PANEL
             ═══════════════════════════════════════════════════════════════ -->
        <div id="hotspots-panel" class="panel">
            <h3>Image & Hotspots</h3>

            <div class="content-block">
                <h4>Manage Image & Hotspots</h4>
                <p>Add interactive hotspots to images in your scene</p>

                <div class="button-container">
                    <button id="add-hotspot-btn">Add Hotspot</button>
                    <button id="edit-hotspot-btn">Edit Selected</button>
                </div>

                <div class="button-container" style="margin-top: 0;">
                    <button id="delete-hotspot-btn">Delete Selected</button>
                </div>
            </div>

            <hr>

            <div class="content-block">
                <h4>Your Images with Hotspots</h4>
                <div id="hotspots-list">
                    <p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">
                        No hotspots yet. Click "Add Hotspot" to create one.
                    </p>
                </div>
            </div>
        </div>
        <!-- ═══════════════════════════════════════════════════════════════
     SCROLLABLE VIDEOS PANEL
     ═══════════════════════════════════════════════════════════════ -->
        <div id="videos-panel" class="panel">
            <h3>Scrollable Videos</h3>

            <div class="content-block">
                <h4>Manage Scrollable Videos</h4>
                <p>Add videos that play frame-by-frame on scroll</p>

                <div class="button-container">
                    <button id="add-video-btn">Add Video</button>
                    <button id="delete-video-btn">Delete Selected</button>
                </div>
            </div>

            <hr>

            <div class="content-block">
                <h4>Your Videos</h4>
                <div id="videos-list">
                    <p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">
                        No videos yet. Click "Add Video" to upload one.
                    </p>
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             AUDIO PANEL
             ═══════════════════════════════════════════════════════════════ -->
        <div id="audio-panel" class="panel">
            <h3>Audio</h3>

            <div class="content-block">
                <h4>Generate Audio</h4>
                <p>Create text-to-speech audio files</p>

                <label>Audio Title</label>
                <input type="text" id="audio-title-input" placeholder="My Audio">

                <label>Text to Speech</label>
                <textarea id="audio-text-input" rows="6" placeholder="Enter text to convert to speech..."></textarea>

                <div class="input-row">
                    <div class="input-group">
                        <label>Voice</label>
                        <select id="audio-voice-select">
                            <option value="af_heart" default>Heart, US</option>
                            <option value="af_alloy">Alloy, US</option>
                            <option value="af_aoede">Aoede, US</option>
                            <option value="af_bella">Bella, US</option>
                            <option value="af_jessica">Jessica, US</option>
                            <option value="af_kore">Kore, US</option>
                            <option value="af_nicole">Nicole, US</option>
                            <option value="af_nova">Nova, US</option>
                            <option value="af_river">River, US</option>
                            <option value="af_sarah">Sarah, US</option>
                            <option value="af_sky">Sky, US</option>

                            <option value="am_adam">Adam, US</option>
                            <option value="am_echo">Echo, US</option>
                            <option value="am_eric">Eric, US</option>
                            <option value="am_fenrir">Fenrir, US</option>
                            <option value="am_liam">Liam, US</option>
                            <option value="am_michael">Michael, US</option>
                            <option value="am_onyx">Onyx, US</option>
                            <option value="am_puck">Puck, US</option>
                            <option value="am_santa">Santa, US</option>

                            <option value="bf_emma">Emma, UK</option>
                            <option value="bf_isabella">Isabella, UK</option>
                            <option value="bm_george">George, UK</option>
                            <option value="bm_lewis">Lewis, UK</option>
                            <option value="bf_alice">Alice, UK</option>
                            <option value="bf_lily">Lily, UK</option>
                            <option value="bm_daniel">Daniel, UK</option>
                            <option value="bm_fable">Fable, UK</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Quality</label>
                        <select id="audio-dtype-select">
                            <option value="q8" selected>Q8 (recommended)</option>
                            <option value="fp32">FP32 (highest)</option>
                            <option value="fp16">FP16 (high)</option>
                            <option value="q4">Q4 (faster)</option>
                            <option value="q4f16">Q4F16 (fast)</option>
                        </select>
                    </div>
                </div>

<button id="generate-audio-btn" style="margin-bottom: 16px;">
    Generate Audio
</button>

                <div id="audio-preview-container"
                    style="display: none; margin: 16px 0; padding: 16px; background: #f7fafc; border-radius: 8px;">
                    <label>Preview</label>
                    <audio id="audio-preview" controls style="width: 100%; margin-top: 8px;"></audio>
                    <p id="audio-info" style="font-size: 12px; color: #718096; margin-top: 8px;"></p>
                </div>

              <button id="save-audio-btn" style="margin-bottom: 8px;">Save Audio</button>
                <button id="delete-audio-btn">Delete Selected</button>
            </div>

            <hr>

            <div class="content-block">
                <h4>Your Audio Files</h4>
                <div id="audio-files-list">
                    <p style="color: #a0aec0; text-align: center; padding: 20px 0; font-style: italic;">
                        No audio files yet. Generate audio above to create one.
                    </p>
                </div>
            </div>
        </div>

        <!-- ═══════════════════════════════════════════════════════════════
             SAVE/LOAD PANEL
             ═══════════════════════════════════════════════════════════════ -->
        <div id="save-load-panel" class="panel">
            <h3>File</h3>


            <div id="status-message" class="status-message"></div>

            <div class="save-load-buttons">
                <button id="save-scene-btn">Save</button>
                <button id="load-scene-btn">Load</button>
                <button id="refresh-projects-btn">Refresh</button>
                <button id="delete-project-btn" style="background: #f56565;">Delete</button>
            </div>
            <hr>

            <div class="content-block">
                <h4>Saved Projects</h4>
                <div id="project-list">
                    <p style="color: #a0aec0; text-align: center; padding: 20px;">Loading projects...</p>
                </div>
            </div>



        </div>

    </div>

    <!-- ═══════════════════════════════════════════════════════════════
         A-FRAME SCENE
         ═══════════════════════════════════════════════════════════════ -->
    <a-scene xr-mode-ui="enabled: false" post-processing="effect: none" vr-mode-ui="enabled: false"
        renderer="antialias: false; colorManagement: true; maxCanvasWidth: 1220; maxCanvasHeight: 1080;">
        <a-entity camera-movement-recorder camera-movement-animator scroll-animator wasd-controls="acceleration:10"
            look-controls camera tooltip-component position="5.132 1.6 7.237"></a-entity>
        <a-grid position="0 -0.1 0"></a-grid>
        <a-sky></a-sky>
    </a-scene>

    <!-- ═══════════════════════════════════════════════════════════════
         MODAL DIALOG
         ═══════════════════════════════════════════════════════════════ -->
    <div id="recording-name-modal" class="modal-overlay">
        <div class="modal-dialog">
            <h3>Save a Camera Path</h3>
            <label for="recording-name-input">Name</label>
            <input type="text" id="recording-name-input" placeholder="Enter camera path name...">
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeRecordingModal()">Cancel</button>
                <button class="btn-save" onclick="saveRecordingWithName()">Save</button>
            </div>
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════
     SECTION EDITOR MODALS
     ═══════════════════════════════════════════════════════════════ -->

    <!-- Article Section Editor -->
    <div id="article-section-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 600px;">
            <h3>Edit Article Section</h3>

            <label>Section Title</label>
            <input type="text" id="article-section-title" placeholder="Introduction">

            <label>Content</label>
            <div id="article-section-editor"
                style="height: 200px; background: white; border: 1px solid #e2e8f0; border-radius: 6px;"></div>

            <label>Background Color</label>
            <input type="color" id="article-section-bg" value="#ffffff">

            <div class="slider-container">
                <div class="slider-header">
                    <label>Min Height (vh)</label>
                    <span class="slider-value" id="article-section-height-value">100</span>
                </div>
                <input type="range" id="article-section-height" min="50" max="200" value="100">
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeArticleSectionModal()">Cancel</button>
                <button class="btn-save" onclick="saveArticleSection()">Save</button>
            </div>
        </div>
    </div>

    <!-- 3D Section Editor -->
    <div id="3d-section-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 500px;">
            <h3>Edit 3D Section</h3>

            <label>Section Name</label>
            <input type="text" id="3d-section-name" placeholder="Product Demo">

            <label>Camera Path</label>
            <select id="3d-section-recording">
                <option value="">Select a camera path...</option>
            </select>

            <div class="slider-container">
                <div class="slider-header">
                    <label>Scroll Duration (vh)</label>
                    <span class="slider-value" id="3d-section-duration-value">300</span>
                </div>
                <input type="range" id="3d-section-duration" min="100" max="500" step="50" value="300">
            </div>

            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin: 16px 0;">
                <input type="checkbox" id="3d-section-has-text" style="width: auto; margin: 0;">
                <span>Enable Text Overlays</span>
            </label>

            <div id="3d-section-text-slides" style="display: none;">
                <h4>Text Slides</h4>
                <p style="font-size: 12px; color: #718096;">Configure these in the Text Slides panel</p>
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="close3DSectionModal()">Cancel</button>
                <button class="btn-save" onclick="save3DSection()">Save</button>
            </div>
        </div>
    </div>

    <!-- Hotspot Section Editor -->
    <div id="hotspot-section-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 500px;">
            <h3>Add Image Hotspot Section</h3>

            <label>Section Name</label>
            <input type="text" id="hotspot-section-name" placeholder="Interactive Product Image">

            <label>Select Hotspot</label>
            <select id="hotspot-section-select">
                <option value="">Select a hotspot...</option>
            </select>

            <label>Background Color</label>
            <input type="color" id="hotspot-section-bg" value="#ffffff">

            <div class="slider-container">
                <div class="slider-header">
                    <label>Min Height (vh)</label>
                    <span class="slider-value" id="hotspot-section-height-value">100</span>
                </div>
                <input type="range" id="hotspot-section-height" min="50" max="200" value="100">
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeHotspotSectionModal()">Cancel</button>
                <button class="btn-save" onclick="saveHotspotSection()">Save</button>
            </div>
        </div>
    </div>

    <!-- Export Article Modal -->
    <div id="export-article-modal" class="modal-overlay">
        <div class="modal-dialog">
            <h3>Export Article</h3>
            <label for="export-article-name-input">Article Name</label>
            <input type="text" id="export-article-name-input" placeholder="my-article">
            <p style="font-size: 12px; color: #718096; margin-bottom: 20px;">
                This will be used for the filename and page title
            </p>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeExportArticleModal()">Cancel</button>
                <button class="btn-save" onclick="confirmExportArticle()">Export</button>
            </div>
        </div>
    </div>

    <!-- Add Slide Modal -->
    <div id="add-slide-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 600px;">
            <h3>Add Text Slide</h3>

            <div class="input-row">
                <div class="input-group">
                    <label>Frame Number</label>
                    <input type="number" id="new-slide-frame" placeholder="Frame number...">
                </div>
                <div class="input-group">
                    <label>Duration (frames)</label>
                    <input type="number" id="new-slide-duration" placeholder="Duration..." min="1">
                </div>
            </div>

            <label>Slide Text</label>
            <div class="quill-editor-container">
                <div id="new-slide-editor"></div>
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeAddSlideModal()">Cancel</button>
                <button class="btn-save" onclick="confirmAddSlide()">Add</button>
            </div>
        </div>
    </div>
    <!-- Save Scene Modal -->
    <div id="save-scene-modal" class="modal-overlay">
        <div class="modal-dialog">
            <h3>Save Scene</h3>
            <label for="save-scene-name-input">Project Name</label>
            <input type="text" id="save-scene-name-input" placeholder="My 3D Scene Project">
            <p style="font-size: 12px; color: #718096; margin-bottom: 20px;">
                Enter a name for your project
            </p>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeSaveSceneModal()">Cancel</button>
                <button class="btn-save" onclick="confirmSaveScene()">Save</button>
            </div>
        </div>
    </div>

    <!-- Delete Projects Modal -->
    <div id="delete-projects-modal" class="modal-overlay">
        <div class="modal-dialog">
            <h3>Delete Projects</h3>
            <p id="delete-projects-message" style="font-size: 14px; color: #4a5568; margin-bottom: 24px;">
                Are you sure you want to delete the selected project(s)?
            </p>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeDeleteProjectsModal()">Cancel</button>
                <button class="btn-save" style="background: #f56565;" onclick="confirmDeleteProjects()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Notification Overlay -->
    <div id="notification-overlay" class="notification-overlay">
        <div id="notification-box" class="notification-box">
            <div id="notification-icon" class="notification-icon"></div>
            <div id="notification-message" class="notification-message"></div>
        </div>
    </div>

    <!-- NEW CODE -->
    <div id="annotation-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 600px;">
            <h3 id="annotation-modal-title">Create Annotation</h3>

            <label>Annotation Name</label>
            <input type="text" id="annotation-name-input" placeholder="My Annotation">

            <label>Background Color</label>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 16px;">
                <input type="color" id="annotation-bg-color" value="#ffffff">
                <span style="font-size: 14px; color: #718096;">Choose background color for the annotation box</span>
            </div>

            <label>Text Content</label>
            <div class="quill-editor-container">
                <div id="annotation-editor" style="height: 200px;"></div>
            </div>

            <div class="slider-container">
                <div class="slider-header">
                    <label>Font Size</label>
                    <span class="slider-value" id="annotation-font-size-value">0.5</span>
                </div>
                <input type="range" id="annotation-font-size" min="0.1" max="2" step="0.1" value="0.5">
            </div>

            <div class="slider-container">
                <div class="slider-header">
                    <label>Max Width</label>
                    <span class="slider-value" id="annotation-max-width-value">2</span>
                </div>
                <input type="range" id="annotation-max-width" min="0.5" max="10" step="0.5" value="2">
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeAnnotationModal()">Cancel</button>
                <button class="btn-save" id="annotation-save-btn" onclick="createAnnotation()">Create</button>
            </div>
        </div>
    </div>

    <!-- Hotspot Creator Modal -->
    <div id="hotspot-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h3>Create Image & Hotspot</h3>

            <label>Name</label>
            <input type="text" id="hotspot-name-input" placeholder="My Interactive Image">

            <label>Upload Image</label>
            <input type="file" id="hotspot-image-upload" accept="image/*">

            <div id="hotspot-canvas-container"
                style="position: relative; margin: 20px 0; border: 2px solid #e2e8f0; border-radius: 8px; display: none; max-height: 500px; overflow: auto;">
                <img id="hotspot-preview-image" style="max-width: 100%; display: block;">
                <canvas id="hotspot-canvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>

            <div id="hotspot-types" style="display: none; margin: 20px 0;">
                <h4>Hotspot Types (Drag onto image)</h4>
                <div style="display: flex; gap: 20px; padding: 20px; background: #f7fafc; border-radius: 8px;">
                    <div class="hotspot-type-draggable" data-type="info" draggable="true"
                        style="cursor: move; padding: 15px; background: white; border: 2px solid #4299e1; border-radius: 50%; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #4299e1;">
                        ℹ️
                        <div style="position: absolute; bottom: -25px; font-size: 12px; white-space: nowrap;">Info</div>
                    </div>
                    <div class="hotspot-type-draggable" data-type="eye" draggable="true"
                        style="cursor: move; padding: 15px; background: white; border: 2px solid #48bb78; border-radius: 50%; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #48bb78;">
                        👁️
                        <div style="position: absolute; bottom: -25px; font-size: 12px; white-space: nowrap;">Eye</div>
                    </div>
                </div>
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeHotspotModal()">Cancel</button>
                <button class="btn-save" onclick="createHotspotEntity()">Create</button>
            </div>
        </div>
    </div>

    <!-- Hotspot Info Modal (for editing individual hotspots) -->
    <div id="hotspot-info-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 600px;">
            <h3 id="hotspot-info-title">Edit Hotspot</h3>

            <label>Hotspot Text</label>
            <textarea id="hotspot-text-input" rows="4" placeholder="Enter hotspot text..."></textarea>

            <div id="hotspot-image-section" style="display: none;">
                <label>Hotspot Image (optional)</label>
                <input type="file" id="hotspot-detail-image" accept="image/*">
                <div id="hotspot-image-preview" style="margin-top: 10px;"></div>
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeHotspotInfoModal()">Cancel</button>
                <button class="btn-save" onclick="saveHotspotInfo()">Save</button>
            </div>
        </div>
    </div>

    <!-- Add Video Modal -->
    <div id="add-video-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 600px;">
            <h3>Add Scrollable Video</h3>

            <label>Video Title</label>
            <input type="text" id="video-title-input" placeholder="My Video">

            <label>Upload Video</label>
            <input type="file" id="video-upload-input" accept="video/*">
            <p style="font-size: 12px; color: #718096; margin-top: 8px;">
                Supported formats: MP4, WebM, OGG
            </p>

            <div id="video-preview-container" style="display: none; margin-top: 16px;">
                <label>Preview</label>
                <video id="video-preview" style="width: 100%; max-height: 300px; border-radius: 8px;" controls></video>
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeAddVideoModal()">Cancel</button>
                <button class="btn-save" onclick="confirmAddVideo()">Add</button>
            </div>
        </div>
    </div>

    <!-- Video Section Modal (for Article Builder) -->
    <div id="video-section-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 500px;">
            <h3>Add Video Section</h3>

            <label>Section Name</label>
            <input type="text" id="video-section-name" placeholder="Product Demo Video">

            <label>Select Video</label>
            <select id="video-section-select">
                <option value="">Select a video...</option>
            </select>

            <label>Background Color</label>
            <input type="color" id="video-section-bg" value="#000000">

            <div class="slider-container">
                <div class="slider-header">
                    <label>Scroll Duration (vh)</label>
                    <span class="slider-value" id="video-section-duration-value">300</span>
                </div>
                <input type="range" id="video-section-duration" min="100" max="500" step="50" value="300">
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeVideoSectionModal()">Cancel</button>
                <button class="btn-save" onclick="saveVideoSection()">Save</button>
            </div>
        </div>
    </div>

    <!-- Audio Section Modal (Selector) -->
    <div id="audio-section-modal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 500px;">
            <h3>Add Audio Section</h3>

            <label>Section Title</label>
            <input type="text" id="audio-section-title" placeholder="Podcast Episode">

            <label>Select Audio</label>
            <select id="audio-section-select">
                <option value="">Select an audio file...</option>
            </select>

            <label>Background Color</label>
            <input type="color" id="audio-section-bg" value="#f7fafc">

            <div class="slider-container">
                <div class="slider-header">
                    <label>Min Height (vh)</label>
                    <span class="slider-value" id="audio-section-height-value">80</span>
                </div>
                <input type="range" id="audio-section-height" min="50" max="200" value="80">
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeAudioSectionModal()">Cancel</button>
                <button class="btn-save" onclick="saveAudioSection()">Add</button>
            </div>
        </div>
    </div>


    <script id="embedded-json-scroll" type="application/json"></script>
    <script id="embedded-text-slides" type="application/json">[]</script>
</body>

</html>